<!DOCTYPE html>
<html lang = "en">
<head>
    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/posts/favico/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/posts/favico/favico/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/posts/favico/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/posts/favico/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/posts/favico/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/posts/favico/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/posts/favico/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/posts/favico/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/posts/favico/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/posts/favico/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/posts/favico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/images/posts/favico/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/posts/favico/favicon-16x16.png">
    <link rel="manifest" href="/assets/images/posts/favico/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/images/posts/favico/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">   

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
    <link href="/assets/css/styles.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet' type='text/css'>
<!--     <script type="text/javascript" src="http://api.youziku.com/webfont/FastJS/yzk_976E121ED7CC0870"></script> -->

    <title>SHUNMIAN</title>
</head>


<body>

    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-3 sidebar hidden-xs sidebar">
                
<!--sidebar.html-->
        <header class="sidebar_header " role="banner">
            <a href="http://www.shunmian.me/index.html">
                <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df?s=150" class="img-circle img-responsive center-block sidebar_logo sidebar_img" />
            </a>


            <h3 class="title text-center">
                <a href="http://www.shunmian.me/index.html">SHUNMIAN</a>
            </h3>

        </header>


        <hr class="hr_short"/>
        <div id = "bio" class="text-center sidebar_bio">
            

                <p>嗨，欢迎来到我的博客。<br/>
                我是Shunmian，一名iOS开发者。<br/>
                <hr class = "hr_short_low">
                正在学习Algorithm，Functional Programming，Machine Learning，Data Mining 和 Cloud Computation。 

                </p>

            
        </div>


        <hr class="hr_middle"/>
        <div id = "contact-list" class="text-center">
            <ul class="list-unstyled list-inline">
                <li>
                    
                    <a class="btn btn_info_outline" href="mailto:shunmian@gmail.com"><i class="fa fa-envelope fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-github fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-twitter fa-lg"></i></a>
                    
                </li>

                <li>
                    <a class="btn btn_info_outline" href="http://www.shunmian.me/feed.xml"><i class="fa fa-rss fa-lg"></i></a>
                </li>
        </div>


        <hr class="hr_short"/>
        <div id = "contact-list" class="text-center">
            <ul class="unstyled-list list-inline">
                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/index.html"><i class="fa fa-home fa-md"></i> 主页</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/tags.html"><i class="fa fa-tags fa-md"></i> 标签</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/categories.html"><i class="fa fa-list fa-md"></i> 分类</a>
                </li>
            </ul>
        </div>
        <div class="padding_bottom_500"></div>




<!--sidebar.html end-->

            </div>

            <div class="col-sm-9 col-sm-offset-3">
                

<div class="page-header col-sm-10 col-sm-offset-1">
    <h1 class="article_mainTitle">FP in Scala(二)：OOP和λ-演算的结合 Part I：万物皆类 && 函数式的体现 </h1>
    <span class="post_date">
        2015-10-04 •
    </span>
    <span class="post_category">
        Functional Programming
    </span>
</div>

<article class="article">
    <div class="col-sm-10 col-sm-offset-1">
        <div class="article_mainBody">
            <p class="article_content_title">目录</p>

<ul id="markdown-toc">
  <li><a href="#oop" id="markdown-toc-oop">1. OOP</a></li>
  <li><a href="#section" id="markdown-toc-section">2. 万物皆类</a>    <ul>
      <li><a href="#primitive-data-is-class" id="markdown-toc-primitive-data-is-class">2.1 Primitive Data is Class</a></li>
      <li><a href="#compound-data-is-class" id="markdown-toc-compound-data-is-class">2.2 Compound Data is Class</a></li>
      <li><a href="#primitive-procedure-is-class" id="markdown-toc-primitive-procedure-is-class">2.3 Primitive Procedure is Class</a></li>
      <li><a href="#compound-procedure-is-class" id="markdown-toc-compound-procedure-is-class">2.4 Compound Procedure is Class</a></li>
    </ul>
  </li>
  <li><a href="#scala" id="markdown-toc-scala">3. Scala中的类</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">3.1 类的关键词</a></li>
      <li><a href="#section-2" id="markdown-toc-section-2">3.2 多态和泛型</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">3.3 类等级</a></li>
      <li><a href="#dynamic-method-dispatch" id="markdown-toc-dynamic-method-dispatch">3.4 运行时和dynamic method dispatch</a></li>
    </ul>
  </li>
  <li><a href="#pattern-matching" id="markdown-toc-pattern-matching">4. 函数式特性的体现:Pattern Matching</a>    <ul>
      <li><a href="#oop-decomposition" id="markdown-toc-oop-decomposition">4.1 OOP Decomposition</a></li>
      <li><a href="#pattern-match-" id="markdown-toc-pattern-match-">4.2 Pattern Match 语法</a></li>
      <li><a href="#pattern-match--1" id="markdown-toc-pattern-match--1">4.3 Pattern Match 例子</a></li>
      <li><a href="#pattern-matching-vs-oop-decomposition" id="markdown-toc-pattern-matching-vs-oop-decomposition">4.4 Pattern Matching vs OOP decomposition</a></li>
    </ul>
  </li>
  <li><a href="#assignment" id="markdown-toc-assignment">5 Assignment</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">6 总结</a></li>
  <li><a href="#section-5" id="markdown-toc-section-5">7 参考资料</a></li>
</ul>

<hr class="hr-short-left" />

<h2 id="oop">1. OOP</h2>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-10-03/compound data.png" alt="compound data" /></p>

<h2 id="section">2. 万物皆类</h2>

<h3 id="primitive-data-is-class">2.1 Primitive Data is Class</h3>

<p>如果说让你定义一个布尔基础类<strong>Boolean</strong>，你会怎么做呢？Scala里的实现如下，先上代码：</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55</pre></td><td class="code"><pre><span class="k">package</span> <span class="nn">week4</span>

<span class="k">object</span> <span class="nc">Main</span><span class="o">{</span>
   
 <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Boolean</span><span class="o">{</span>
   
    <span class="k">def</span> <span class="n">ifThenElse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">e1</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    
    <span class="k">def</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">b2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">ifThenElse</span><span class="o">(</span><span class="n">b2</span><span class="o">,</span><span class="nc">False</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">||</span> <span class="o">(</span><span class="n">b2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">ifThenElse</span><span class="o">(</span><span class="nc">True</span><span class="o">,</span><span class="n">b2</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">unary_!</span> <span class="k">:</span> <span class="kt">Boolean</span>            <span class="o">=</span> <span class="n">ifThenElse</span><span class="o">(</span><span class="nc">False</span><span class="o">,</span><span class="nc">True</span><span class="o">)</span>
    
    <span class="k">def</span> <span class="o">==</span> <span class="o">(</span><span class="n">b2</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">ifThenElse</span><span class="o">(</span><span class="n">b2</span><span class="o">,</span> <span class="n">b2</span><span class="o">.</span><span class="n">unary_!</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">!=</span> <span class="o">(</span><span class="n">b2</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">ifThenElse</span><span class="o">(</span><span class="n">b2</span><span class="o">.</span><span class="n">unary_!</span><span class="o">,</span> <span class="n">b2</span><span class="o">)</span>
  <span class="o">}</span>
  
  <span class="k">object</span> <span class="nc">True</span> <span class="k">extends</span> <span class="nc">Boolean</span><span class="o">{</span>
    <span class="k">def</span> <span class="n">ifThenElse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">e1</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">e1</span>
  <span class="o">}</span>
  
  <span class="k">object</span> <span class="nc">False</span> <span class="k">extends</span> <span class="nc">Boolean</span><span class="o">{</span>
    <span class="k">def</span> <span class="n">ifThenElse</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">e1</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">e2</span>
  <span class="o">}</span>
  
   <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
     
    <span class="k">def</span> <span class="n">p</span><span class="o">(</span><span class="n">b</span><span class="k">:</span><span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="n">b</span><span class="o">.</span><span class="n">ifThenElse</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="s">"True"</span><span class="o">),</span><span class="n">println</span><span class="o">(</span><span class="s">"False"</span><span class="o">))</span> 
     
    <span class="n">p</span><span class="o">(</span><span class="nc">True</span><span class="o">)</span>               <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span><span class="o">)</span>              <span class="c1">//False
</span>    
    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">&amp;&amp;</span> <span class="nc">False</span><span class="o">)</span>      <span class="c1">//False
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">&amp;&amp;</span> <span class="nc">True</span><span class="o">)</span>       <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">&amp;&amp;</span> <span class="nc">True</span><span class="o">)</span>      <span class="c1">//False
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">&amp;&amp;</span> <span class="nc">False</span><span class="o">)</span>     <span class="c1">//False
</span>    
    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">||</span> <span class="nc">False</span><span class="o">)</span>      <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">||</span> <span class="nc">True</span><span class="o">)</span>       <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">||</span> <span class="nc">True</span><span class="o">)</span>      <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">||</span> <span class="nc">False</span><span class="o">)</span>     <span class="c1">//False
</span>    
    <span class="n">p</span><span class="o">(!</span><span class="nc">True</span><span class="o">)</span>              <span class="c1">//False
</span>    <span class="n">p</span><span class="o">(!</span><span class="nc">False</span><span class="o">)</span>             <span class="c1">//True
</span>
    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">==</span> <span class="nc">False</span><span class="o">)</span>      <span class="c1">//False
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">==</span> <span class="nc">True</span><span class="o">)</span>       <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">==</span> <span class="nc">False</span><span class="o">)</span>     <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">==</span> <span class="nc">True</span><span class="o">)</span>      <span class="c1">//Flase
</span>    
    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">!=</span> <span class="nc">False</span><span class="o">)</span>      <span class="c1">//True
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">True</span> <span class="o">!=</span> <span class="nc">True</span><span class="o">)</span>       <span class="c1">//False
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">!=</span> <span class="nc">False</span><span class="o">)</span>     <span class="c1">//False
</span>    <span class="n">p</span><span class="o">(</span><span class="nc">False</span> <span class="o">!=</span> <span class="nc">True</span><span class="o">)</span>      <span class="c1">//True
</span>  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>课程里只是给了如上一个完成了的Boolean的实现，令人感叹于它的优雅。可是如果是让你重头开始自己设计Boolean，怎样才能获得这样的结果呢？对于编程学习者，我们渴求的不是Boolean的实现，而是Boolean实现的思路；正如物理学家渴求的不是相对论，而是发现相对论的那个头脑。我们来试着思考下：</p>

<ol>
  <li>首先，<code class="highlighter-rouge">Boolean</code>有两个子类<code class="highlighter-rouge">True</code>和<code class="highlighter-rouge">False</code>，这是毋庸置疑的；</li>
  <li>这两个子类实现的最基本的功能应该就是单元操作，而不是多元操作；</li>
  <li>那么我们先看看单元操作，有取反<code class="highlighter-rouge">!</code>，和条件判断 <code class="highlighter-rouge">if (b:Boolean) e1 else e2</code>；</li>
  <li>我们暂且将这个函数定义为<code class="highlighter-rouge">def ifThenElse[T](e1: =&gt; T, e2: =&gt; T): T</code>，即假定Scala已经自动实现了上述将<code class="highlighter-rouge">if (b:Boolean) e1 else e2</code>转换成<code class="highlighter-rouge">b.ifThenElse(e1,e2)</code>；</li>
  <li>那么两个子类<code class="highlighter-rouge">True</code>和<code class="highlighter-rouge">False</code>对该函数的实现分别为返回<code class="highlighter-rouge">e1</code>和<code class="highlighter-rouge">e2</code>也就理所应当了；</li>
  <li>在这个基础上，我们尝试用<code class="highlighter-rouge">ifThenElse[T](e1: =&gt; T, e2: =&gt; T): T</code>实现取反的单元操作和其他二元操作，结果证明是可行的。</li>
</ol>

<p>我觉得上述思路应该是一个正常的思路，如果一开始就尝试用一个general的公式取实现Boolean所有的单元和多元操作，比较困难。我们留一个小问题，请同学自己实现Boolean的 <strong>&lt; method</strong>.</p>

<p>最后Boolean的实现用以下这张图表示。</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-10-04/Boolean.png" alt="Boolean" /></p>

<h3 id="compound-data-is-class">2.2 Compound Data is Class</h3>

<p>这个同学们应该都很熟悉了，就是最常见的类的对data和function的封装(当function被封装在类里，我们称之为method，具体区别见<a href="http://www.shunmian.me/functional%20programming/2015/10/04/Functional-Programming-in-Scala(二)_OOP和λ-演算的结合.html#compound-procedure-is-class">2.4</a>。我们重新改写<a href="http://www.shunmian.me/functional%20programming/2015/10/03/Functional-Programming-in-Scala(一)_λ-演算-Part-III-抽象数据.html">λ-演算 Part III：抽象数据</a>的有理数的例子，将<strong>Compound Data</strong>改写成<strong>类</strong>，只需将函数封装到数据里面即可。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">Main</span> <span class="o">{</span>

  <span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"demoninator must be non-zero"</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">gcd</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">denomi</span> <span class="k">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">gcd</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>

    <span class="c1">// compared to the previous compound data example, here function are defined inside Rational
</span>    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="n">denomi</span>

    <span class="k">def</span> <span class="n">makeRationl</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">neg</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(-</span><span class="n">r</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="n">denomi</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">r2</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denomi</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="n">denomi</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">denomi</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denomi</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">sub</span><span class="o">(</span><span class="n">r2</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">neg</span><span class="o">(</span><span class="n">r2</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">less</span><span class="o">(</span><span class="n">r2</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">denomi</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="n">denomi</span> <span class="o">*</span> <span class="n">r2</span><span class="o">.</span><span class="n">numer</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">r2</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">less</span><span class="o">(</span><span class="n">r2</span><span class="o">))</span> <span class="n">r2</span> <span class="k">else</span> <span class="k">this</span>

  <span class="o">}</span>

  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">r1</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">r2</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    
    <span class="k">val</span> <span class="n">r3</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">r2</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">r3</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">r4</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">sub</span><span class="o">(</span><span class="n">r2</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">r4</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">r5</span> <span class="k">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="n">r2</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">r5</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="primitive-procedure-is-class">2.3 Primitive Procedure is Class</h3>

<p>那么如何将诸如+,-,*,\的<strong>Primitive Procedure</strong>表示成类呢，其实我们在<a href="http://www.shunmian.me/functional%20programming/2015/10/04/Functional-Programming-in-Scala(二)_OOP和λ-演算的结合.html#compound-procedure-is-class">2.1</a>已经看到了如何将。。——————————————</p>

<h3 id="compound-procedure-is-class">2.4 Compound Procedure is Class</h3>

<p><strong>Compound Procedure</strong>即<strong>函数</strong>，在scala里，函数如何才能使一个类呢？</p>

<blockquote>
  <p><strong>function variable</strong> are <strong>class</strong>，and <strong>function value</strong> are <strong>object</strong>。<br />
<strong>function value</strong> is from instantiation of function literals(anonymous functions)。</p>
</blockquote>

<p>如果一个函数的类型是 <code class="highlighter-rouge">A=&gt;B</code>，那么在scala里，这会转成<code class="highlighter-rouge">scala.Function1[A,B]</code>，其中A和B是泛型，1表示输入参数是1个，Function1[A,B]表示1个输入类型A和1个输出类型B的函数类。那么这个类的定义是什么呢？是一个如下的接口，</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span><span class="k">:</span><span class="kt">B</span>
<span class="o">}</span>

<span class="c1">//变量f1是Int=&gt;Int的函数，函数体是(x:Int)=&gt;x*x；这个定义的完整版如下f2(f1,和f2等价)
</span><span class="k">val</span> <span class="n">f1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">=&gt;</span><span class="nc">Int</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">=&gt;</span><span class="n">x</span><span class="o">*</span><span class="n">x</span>

<span class="c1">//变量f2，实例化一个Function1[A,B]的子类Function1[Int,Int],其中的apply method的实现就是f1中的函数体。
</span><span class="k">val</span> <span class="n">f2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">=</span><span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="o">}</span>

<span class="c1">//f1调用
</span><span class="n">f1</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>			<span class="c1">//9
</span>
<span class="c1">//f1会被转换成
</span><span class="n">f1</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>		<span class="o">//</span><span class="mi">9</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>上面f2实例化一个Function1[A,B]的子类Function1[Int,Int],其中的apply method的实现就是f1中的函数体。</p>

<p>也许有人会问，apply 会再实例化一个函数类吗，如果会，不就陷入死循环了吗？</p>

<p>这里我们要着重讲解两个概念<strong>Function vs Method</strong>。</p>

<blockquote>
  <p>A <strong>function</strong> in Scala is a complete object，which <strong>contains methods</strong>， One of these methods is the apply method， which contains the code that implements the body of the function。 A method(an OOP concept) is defined within class and without class, there is no method。</p>
</blockquote>

<p>在了解function和method的关系下，有几个method和function相互替代的地方需要注意：</p>

<ol>

<li> method 只能是def，function可以是val(即一个变量指向一个函数object)。</li>
<li> method可以被隐式转换成function，如：


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="k">def</span> <span class="n">m</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="k">val</span> <span class="n">f</span>  <span class="k">=</span> <span class="n">m</span>    			  <span class="c1">//error
</span><span class="k">val</span> <span class="n">f1</span> <span class="k">=</span> <span class="n">m</span> <span class="k">_</span>  			  <span class="c1">//return a new Function1[Int,Int]{def apply(x:Int)=x*x}
</span><span class="k">val</span> <span class="n">f2</span> <span class="k">=</span> <span class="n">m</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> 			  <span class="c1">//the same as f1
</span><span class="k">val</span> <span class="n">f3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]{</span>	  <span class="c1">//f1,f2 are actually converted as f3
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">=</span> <span class="n">m</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


</li>


<li> function通常比实现同样功能的method占用更多内存，但是function可以有OOP带来的其它好处，比如Scala默认实现了toString()。所以有些时候用function用内存换来的性能是值得的。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="k">def</span> <span class="n">m</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="n">m</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>	<span class="c1">//error
</span><span class="n">f1</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>	<span class="o">//</span><span class="n">res5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">function1</span><span class="o">&gt;&amp;</span><span class="n">gt</span><span class="o">;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


</li>

<li>def evaluates every time it gets called while val evaluates only once。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="k">def</span> <span class="n">isDivisibleBy</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="k">=</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">isEven1</span> <span class="k">=</span> <span class="n">isDivisibleBy</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>		
<span class="n">isEven1</span><span class="o">(</span><span class="mi">2</span><span class="o">)(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">isEven1</span><span class="o">(</span><span class="mi">2</span><span class="o">)(</span><span class="mi">5</span><span class="o">)</span>			<span class="c1">// isDivisibleBy(k: Int): Int =&gt; Boolean is called every time
</span>
<span class="k">val</span> <span class="n">isEven2</span> <span class="k">=</span> <span class="n">isDivisibleBy</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>	
<span class="n">isEven2</span><span class="o">(</span><span class="mi">2</span><span class="o">)(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">isEven2</span><span class="o">(</span><span class="mi">2</span><span class="o">)(</span><span class="mi">5</span><span class="o">)</span>			<span class="o">//</span> <span class="n">isDivisibleBy</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span> <span class="n">is</span> <span class="n">called</span> <span class="n">only</span> <span class="n">once</span> <span class="n">during</span> <span class="k">val</span> <span class="n">isEven2</span><span class="ss">'s </span><span class="n">definition</span><span class="o">.</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


</li>


</ol>

<h2 id="scala">3. Scala中的类</h2>

<p>既然<strong>Scala</strong>中万物皆类，我们来看下类需要特别注意的地方，包括语法和类等级(Class Hierachy)。</p>

<h3 id="section-1">3.1 类的关键词</h3>

<p>Scala里类的语法还有以下关键词。</p>

<ol>

<li><b>this</b>，和Java里的this一样，在类里指自己这个实例。但是Scala里的<b>this</b>还可以是一个构造器。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>		<span class="c1">//这是一个默认构造器
</span><span class="o">...</span>
  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span> 		<span class="c1">//如果只输入一个参数x，那么自动生成分子为x，分母为1的Rational实例
</span><span class="o">...</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

</li>

<li><b>require</b>，used to enforce a precondition on the caller of a function。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">,</span> <span class="s">"demoninator must be non-zero"</span><span class="o">)</span>	<span class="c1">//用来规定一个precondition，当对Rational构造器调用时。
</span><span class="o">...</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

</li>

<li><b>assert</b>，used to check the code of the function itself。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>	
<span class="o">...</span>
  <span class="n">assert</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>		<span class="c1">// up to here，check whether y!=0
</span><span class="o">...</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


<b>assert</b>和<b>assert</b>的区别在他们各自的定义里基本说清楚了，需要补充的是<b>assert</b>其实更多的是类的implementation的时候的先决条件，而<b>assert</b>更多的是一种对程序当前状态是否已达预期的一种判断。

</li>

<li><b>trait</b>，类似Java里的interface，但是比它强大，因为<b>trait</b>可以有<b>method</b>的具体实现和field(但是不能有value)。<b>Swift的protocal</b>和<b>Scala的trait</b>非常相似。


<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Movable</span><span class="o">{</span>	
<span class="o">...</span>
  <span class="k">val</span> <span class="n">speed</span><span class="k">:</span><span class="kt">Int</span><span class="err">；</span>			<span class="c1">//field cannot have value
</span>  <span class="k">def</span> <span class="n">trace</span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> 	<span class="c1">//method can have implementation，can be override
</span><span class="o">...</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

</li>
</ol>

<h3 id="section-2">3.2 多态和泛型</h3>

<blockquote><b>Polymorphism(多态)</b>，在OOP中有两种形式存在于类中：
<ol>
<li> 类的<b>subTyping</b>，即当需要一个父类的时候，子类可以代替父类；</li>
<li> 类的<b>generic</b>，即定义类和定义类中的method的时候，input argument type can be parameterized。</li>
</ol>
</blockquote>

<h3 id="section-3">3.3 类等级</h3>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-10-04/scala class hierarchy.png" alt="scala class hierarchy" /></p>

<p>在Scala里，类等级(Class Hierachy)如上图所示：</p>

<ol>
  <li>
    <p>所有类的祖先是<code class="highlighter-rouge">Any</code>。<code class="highlighter-rouge">Any</code>又包括<code class="highlighter-rouge">AnyVal</code>和<code class="highlighter-rouge">AnyRef</code>，即分别是<strong>Primitive Data</strong>和<strong>Compound Data</strong>；</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">AnyRef</code>里的底部的子类是<code class="highlighter-rouge">Null</code>，<code class="highlighter-rouge">AnyVal</code>里的底部的子类是<code class="highlighter-rouge">Nothing</code>。同时<code class="highlighter-rouge">Nothing</code>又是<code class="highlighter-rouge">Null</code>的子类。</p>
  </li>
  <li>
    <p>关于<code class="highlighter-rouge">AnyRef</code>里的<code class="highlighter-rouge">Iterable</code>，<code class="highlighter-rouge">Seq</code>，<code class="highlighter-rouge">List</code>等接口我们暂且不表。</p>
  </li>
</ol>

<h3 id="dynamic-method-dispatch">3.4 运行时和dynamic method dispatch</h3>

<p>这里暂且不表，具体请先参见<a href="http://www.shunmian.me/objective-c/2016/03/14/OC-Runtime(一)_Sending-Message.html">Objective-C的runtime系列</a>。</p>

<h2 id="pattern-matching">4. 函数式特性的体现:Pattern Matching</h2>

<p><strong>pattern match</strong>是Scala为了避免为同一类添加一个新方法导致大量修改子类。由于<strong>OOP和λ-Calculus</strong>结合的函数式(递归)特性催生了这一<strong>pattern match</strong>模式。下面我们以一个算术表达式为例子(有Number，表示数字；Sum，有左Operand和右Operand)，逐步理解<strong>pattern match</strong>的来历，优点及不足。</p>

<h4 id="oop-decomposition">4.1 OOP Decomposition</h4>

<blockquote>
  <p><strong>Object-oriented decomposition</strong>： breaks a large system down into progressively smaller classes or objects that are responsible for some part of the problem domain。</p>
</blockquote>

<p>我们将<code class="highlighter-rouge">Number</code>和<code class="highlighter-rouge">Sum</code>同时抽象成<code class="highlighter-rouge">Expr</code>接口。<code class="highlighter-rouge">Expr</code>接口里，我们分别实现了classification和accessor为了同时满足Number和Sum的操作(其实有冗余，<code class="highlighter-rouge">Sum</code>不需要<code class="highlighter-rouge">numberValue</code>，同时<code class="highlighter-rouge">Number</code>不需要<code class="highlighter-rouge">leftOp</code>，<code class="highlighter-rouge">rightOp</code>)。我们让<code class="highlighter-rouge">Number</code>和<code class="highlighter-rouge">Sum</code>同时实现<code class="highlighter-rouge">Expr</code>接口(即实现这5个method)。最后我们定义了一个<code class="highlighter-rouge">eval(e: Expr): Int</code> method 来实现最终的赋值。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td><td class="code"><pre><span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
  <span class="c1">//classification
</span>  <span class="k">def</span> <span class="n">isNumber</span><span class="k">:</span> <span class="kt">Boolean</span>          
  <span class="k">def</span> <span class="n">isSum</span><span class="k">:</span> <span class="kt">Boolean</span>
  
  <span class="c1">//accessor
</span>  <span class="k">def</span> <span class="n">numValue</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">leftOp</span><span class="k">:</span><span class="kt">Expr</span>
  <span class="k">def</span> <span class="n">rightOp</span><span class="k">:</span><span class="kt">Expr</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">{</span>    <span class="c1">//the Number subclass
</span>  
  <span class="k">def</span> <span class="n">isNumber</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="k">def</span> <span class="n">isSum</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
  
  <span class="k">def</span> <span class="n">numValue</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">def</span> <span class="n">leftOp</span><span class="k">:</span><span class="kt">Expr</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Number.leftOp"</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">rightOp</span><span class="k">:</span><span class="kt">Expr</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Number.rigthOp"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">left</span><span class="k">:</span><span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span><span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">{</span>
  
  <span class="k">def</span> <span class="n">isNumber</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="k">def</span> <span class="n">isSum</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
  
  <span class="k">def</span> <span class="n">numValue</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Sum.numValue"</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">leftOp</span><span class="k">:</span><span class="kt">Expr</span> <span class="o">=</span> <span class="n">left</span>
  <span class="k">def</span> <span class="n">rightOp</span><span class="k">:</span><span class="kt">Expr</span> <span class="o">=</span> <span class="n">right</span>
<span class="o">}</span>


<span class="k">object</span> <span class="nc">ExprTest</span> <span class="k">extends</span> <span class="nc">App</span><span class="o">{</span>
 
  <span class="k">def</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">isNumber</span><span class="o">)</span> <span class="n">e</span><span class="o">.</span><span class="n">numValue</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">isSum</span><span class="o">)</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">leftOp</span><span class="o">)</span> <span class="o">+</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">rightOp</span><span class="o">)</span>
    <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Unknown expression"</span> <span class="o">+</span> <span class="n">e</span><span class="o">)</span>
  <span class="o">}</span>
  
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">(</span><span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">())</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>上面的代码对于实现<code class="highlighter-rouge">Number</code>和<code class="highlighter-rouge">Sum</code>是没有问题的，但是它的扩展性不好，比如我们需要增加一个子类<code class="highlighter-rouge">Prod</code>用来计算乘积和一个子类<code class="highlighter-rouge">Val</code>来表示变量，我们需要如何改动呢：</p>

<ul>
  <li>Expr的接口里需要再增加3个方法，<code class="highlighter-rouge">isProd</code>，<code class="highlighter-rouge">isVal</code>，<code class="highlighter-rouge">val</code>。前两个是classification，第3个是accessor；</li>
  <li><code class="highlighter-rouge">Number</code>和<code class="highlighter-rouge">Sum</code>需要实现这额外的3个方法。</li>
  <li>新增的<code class="highlighter-rouge">Prod</code>和<code class="highlighter-rouge">Val</code>需要各自实现8个方法。</li>
</ul>

<p>所以增加2个新的类一共需要实现25个额外的方法，额外方法的个数与新增子类的个数呈平方关系，有点不好接受。那么如何解决这个问题呢，我们看下面几种解决方法</p>

<ol>
<li><b>Non-Solution：Type Tests and Type Casts</b><br />

我们在`Expr`里减少这5个方法，在<code>Number</code>，<code>Sum</code>，<code>Prod</code>和<code>Val</code>各自实现各自所需的方法。这样做就不需要<code>Expr</code>的子类实现多余的方法。在<code>def eval(e:Expr):Int</code>里我们只需要用<b>Type Tests</b>和<b>Type Casts</b>来进行实现。<br />

<p><img src="/assets/images/posts/2015-10-04/type checking.png" align="middle" /></p>

<br />



<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre> <span class="k">def</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span><span class="kt">Expr</span><span class="o">)</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
   <span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">])</span> <span class="n">e</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Number</span><span class="o">].</span><span class="n">numValue</span>
   <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Sum</span><span class="o">])</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Sum</span><span class="o">].</span><span class="n">leftOp</span><span class="o">)</span> <span class="o">+</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Sum</span><span class="o">].</span><span class="n">rightOp</span><span class="o">)</span>
   <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="o">(</span><span class="s">"Unknown expression"</span> <span class="o">+</span> <span class="n">e</span><span class="o">)</span> 
 <span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


这个方法的优点是不需要classficiation和accesor方法在<code>Expr</code>里，只需要将access方法在只需要的类里实现即可；缺点是<b>low-level</b> and <b>potentially unsafe</b>。因此我们把这个方法称为<b>Non-Solution</b>。
<br />
</li>

<li><b>1st-Solution：Object-oriented decomposition</b>

<blockquote><b>Object-oriented decomposition</b>： breaks a large system down into progressively smaller classes or objects that are responsible for some part of the problem domain。</blockquote>



<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="c1">//OOP decomposition
</span><span class="k">trait</span> <span class="nc">Expr</span><span class="o">{</span>
  <span class="k">def</span> <span class="n">eval</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">{</span>
  <span class="k">def</span> <span class="n">eval</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span><span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span><span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">{</span>
  <span class="k">def</span> <span class="n">eval</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="n">e1</span><span class="o">.</span><span class="n">eval</span> <span class="o">+</span> <span class="n">e2</span><span class="o">.</span><span class="n">eval</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ExprTest</span> <span class="k">extends</span> <span class="nc">App</span><span class="o">{</span>
    <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sum</span><span class="o">(</span><span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">())</span>
<span class="o">}</span>	<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>


<b>OOP decomposition</b>看起来简单多了，如果再需要扩展<code>Prod</code>和<code>Val</code>子类，只需要各自实现如上<code>eval</code> method即可。但是如果我们需要一个方法来展示<b>Expr</b>呢，比如说<code>Show</code> method，我们需要在<code>Expr</code>所有的子类里定义这个新方法。另外如果我们需要实现 a * b + a * c -&gt; a * (b + c)这个提取公因式的method，我们该如何做呢。由于这个方法涉及不同的子类，因此无法通过在一个子类里的method实现，我们必须又得回到该开始的平方增加的例子(增加access method在所有子类里)。

</li>

</ol>

<h4 id="pattern-match-">4.2 Pattern Match 语法</h4>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-10-04/why pattern matching.png" alt="why pattern matching" /></p>

<p>我们来对前面的问题做一个小结，我们的任务是想要同时在<strong>扩展子类</strong>和<strong>扩展接口方法</strong>(接口方法指的是适合所有子类，定义在接口里，而具体实现需要access subclass’s own method implementation，即<strong>子类方法</strong>)上获取一个普适的方便的方法：</p>

<ol>
  <li>第一种方法，是将子类<strong>classificatoin</strong>和<strong>子类方法</strong>全部声明在接口中，这样做的弊端是产生了很多不必要的方法，<strong>原有方法的实现</strong>和<strong>扩展类的个数</strong>呈<strong>平方</strong>关系，这还不包括<strong>扩展新的接口方法</strong>，因此这种方法效率极其低下，耦合太紧；</li>
  <li>第二种non-solution，在<strong>接口方法</strong>里用<strong>type tests</strong>和<strong>type casts</strong>分别调用<strong>子类方法</strong>。这样如果<strong>扩展子类</strong>只需要在新子类中自己实现相应的<strong>接口方法</strong>调用的<strong>子类方法</strong>，然后在<strong>接口</strong>方法里增加对于这个新的子类的<strong>type tests</strong>和<strong>type casts</strong>。这样做相比于第一个方法貌似灵活了许多，但是却是<strong>low-level</strong>和<strong>unsafe</strong>的；</li>
  <li>第三种方法是OOP的decomposition，这其实是我们现在对<strong>接口</strong>的最常用的方法。现在看起来理所当然的方法，但是当我们一步步从这之前走到decomposition所要比较和改进的思路不是那么容易的。OOP的decomposition即在接口里定义<strong>接口方法</strong>，然后在<strong>子类</strong>中直接实现。如果需要<strong>扩展子类</strong>，只需要在子类中实现已有的<strong>接口方法</strong>；如果需要<strong>扩展接口方法</strong>，只需要在接口里<strong>定义新接口方法</strong>，然后分别在<strong>子类里增加实现</strong>。这样我们将<strong>扩展子类</strong>和<strong>扩展接口方法</strong>解耦，使得OOP的Class有着灵活的扩展性。但是对于<strong>扩展接口方法</strong>我们能否做的更好呢？下面我们看看<strong>Pattern Match</strong>。</li>
</ol>

<p>先上代码。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">ExprTest</span> <span class="k">extends</span> <span class="nc">App</span><span class="o">{</span>
  <span class="k">trait</span> <span class="nc">Expr</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span><span class="kt">Expr</span><span class="o">,</span><span class="n">e2</span><span class="k">:</span><span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
  
  <span class="cm">/* implicit define the companion factory method,Number(2) would be Number.apply(2). No need to use new Number(2) anymore
    object Number{
    def apply(n:Int) = new Number(n)
  }
  
  object Sum{
    def apply(e1:Expr,e2:Expr) = new Sum(e1,e2)
  }
  */</span>
  
  <span class="c1">//pattern match 
</span>  <span class="k">def</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span><span class="kt">Expr</span><span class="o">)</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span><span class="o">{</span>
    <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span>
    <span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">+</span> <span class="n">eval</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span>
  <span class="o">}</span>  
  
  <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">e</span><span class="k">:</span><span class="kt">Expr</span><span class="o">)</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span><span class="o">{</span>
    <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
    <span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"( "</span> <span class="o">+</span> <span class="n">show</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" + "</span> <span class="o">+</span> <span class="n">show</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">+</span> <span class="s">" )"</span>
  <span class="o">}</span>
  
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Sum</span><span class="o">(</span><span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">println</span><span class="o">(</span><span class="n">show</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>我们来一一解释：</p>

<ol>
  <li>首先定义了一个接口 Expr，然后显示表示这个接口的子类是一个所有需要的子类的<strong>枚举</strong>，关键词是<strong>case</strong>。在Scala里这就隐式声明了各个需要子类的工厂方法，当你调用<code class="highlighter-rouge">Number(2)</code>的时候，会被转换成<code class="highlighter-rouge">Number.apply(2)</code>(apply的实现就是<code class="highlighter-rouge">new Number(n)</code>，即new了一个新的Number实例)。</li>
</ol>

<p>2.然后在接口里直接实现了接口方法，用的就是<strong>Pattern Match</strong>。枚举分流接口方法的子类类型，这里可以看到有在<code class="highlighter-rouge">Sum</code>里有递归调用，这是<strong>函数式的体现</strong>。</p>

<ol>
  <li>如果我们需要<strong>扩展接口方法</strong>，比如增加一个<code class="highlighter-rouge">Show</code>的接口方法，同样的使用<strong>Pattern Match</strong>。这样对比与OOP的decomposiont的<strong>扩展接口方法</strong>，可以看到更加简洁方便(不需要在每一个子类中分别实现<strong>接口方法</strong>)。</li>
</ol>

<blockquote>
  <p>因此<strong>Pattern Matching</strong>可以说是函数式OOP的核心(递归调用)，是对命令式OOP接口decompostion的一个提升。<strong>Pattern Matching</strong>建立在scala的<strong>trait</strong>可以有method的实现，和函数式的递归基础上。</p>
</blockquote>

<p><strong>Pattern Matching</strong>的语法如下图</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-10-04/pattern matching.png" alt="pattern matching" /></p>

<h4 id="pattern-match--1">4.3 Pattern Match 例子</h4>

<p>现在我们将上面这个例子重新改写，将pattern matching 封装在<code class="highlighter-rouge">Expr</code>里。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="k">object</span> <span class="nc">ExprTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="c1">//将pattern matching 封装在trait里
</span>  <span class="k">trait</span> <span class="nc">Expr</span> <span class="o">{</span>
    <span class="c1">//pattern match 
</span>    <span class="k">def</span> <span class="n">eval</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">n</span>
      <span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e1</span><span class="o">.</span><span class="n">eval</span> <span class="o">+</span> <span class="n">e2</span><span class="o">.</span><span class="n">eval</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">toString</span><span class="o">()</span>
      <span class="k">case</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"( "</span> <span class="o">+</span> <span class="n">show</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" + "</span> <span class="o">+</span> <span class="n">show</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="o">+</span> <span class="s">" )"</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">Sum</span><span class="o">(</span><span class="n">e1</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>

  <span class="cm">/* implicit define the companion factory method,Number(2) would be Number.apply(2). No need to use new Number(2) anymore
    object Number{
    def apply(n:Int) = new Number(n)
  }
  
  object Sum{
    def apply(e1:Expr,e2:Expr) = new Sum(e1,e2)
  }
  */</span>

  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Sum</span><span class="o">(</span><span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">)).</span><span class="n">eval</span><span class="o">()</span>
  <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>这就是<code class="highlighter-rouge">Expr</code>的最终的实现形式，如果需要<strong>扩展子类</strong>和<strong>扩展接口方法</strong>，聪明的你，肯定知道怎么做了^_^。</p>

<h3 id="pattern-matching-vs-oop-decomposition">4.4 Pattern Matching vs OOP decomposition</h3>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-10-04/pattern matching vs oop decompostion.png" alt="pattern matching vs oop decompostion" /></p>

<p><strong>Pattern Maching</strong>和<strong>OOP Decompostion</strong>各有优劣，那么在我们实际编程中，该如何选择呢：</p>

<ul>
  <li>如果更多的是<strong>扩展子类</strong>，则用<strong>OOP Decompostion</strong>；</li>
  <li>如果更多的是<strong>扩展接口方法</strong>，则用<strong>Pattern Matching</strong></li>
</ul>

<h2 id="assignment">5 Assignment</h2>

<p>本周作业是霍夫曼编码，其中的难点是如何用tuple来做pattern matching来简化实现，举个具体的例子，<code class="highlighter-rouge">def decode(tree: CodeTree, bits: List[Bit]): List[Char]</code>将整数链表转换成字母链表。用<code class="highlighter-rouge">tuple</code>只需要4个pattern。但是需要格外小心的是4个pattern的先后顺序，一个实用的经验是从一次完整的函数调用来排列case的顺序。比如这里，对于一个正常的<code class="highlighter-rouge">tree:CodeTree</code>，如果<code class="highlighter-rouge">bits0</code>是0开头，则进入左边的<code class="highlighter-rouge">subtree</code>，1开头则进入右边的<code class="highlighter-rouge">subtree</code>；如果碰到叶子节点，则将<code class="highlighter-rouge">char</code>加入到<code class="highlighter-rouge">acc</code>，然后从头开始调用<code class="highlighter-rouge">tree</code>和剩下的<code class="highlighter-rouge">bits0</code>；最后当<code class="highlighter-rouge">bits0</code>满足<code class="highlighter-rouge">Nil</code>时，返回<code class="highlighter-rouge">acc</code>。</p>

<p>这里请同学们思考一个问题，如果将第三个case的<code class="highlighter-rouge">a</code>改成<code class="highlighter-rouge">x::xs</code>，结果还是正确的吗？答案是不正确的，因为最后一个字母没有被加入到<code class="highlighter-rouge">acc</code>里(<code class="highlighter-rouge">x::xs</code>将<code class="highlighter-rouge">Nil</code>的情况给剔除了)。</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre>  <span class="cm">/**
   * This function decodes the bit sequence `bits` using the code tree `tree` and returns
   * the resulting list of characters.
   */</span>

  <span class="k">def</span> <span class="n">decode</span><span class="o">(</span><span class="n">tree</span><span class="k">:</span> <span class="kt">CodeTree</span><span class="o">,</span> <span class="n">bits</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Bit</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">decode0</span><span class="o">(</span><span class="n">tree0</span><span class="k">:</span> <span class="kt">CodeTree</span><span class="o">,</span> <span class="n">bits0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Bit</span><span class="o">],</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">tree0</span><span class="o">,</span> <span class="n">bits0</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Fork</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">chars</span><span class="o">,</span> <span class="n">weight</span><span class="o">),</span> <span class="mi">0</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">decode0</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">xs</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Fork</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">chars</span><span class="o">,</span> <span class="n">weight</span><span class="o">),</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">decode0</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">xs</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Leaf</span><span class="o">(</span><span class="n">char</span><span class="o">,</span> <span class="n">weight</span><span class="o">),</span> <span class="n">a</span><span class="o">)</span>                     <span class="k">=&gt;</span> <span class="n">decode0</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">acc</span> <span class="o">:+</span> <span class="n">char</span><span class="o">)</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>                                    <span class="k">=&gt;</span> <span class="n">acc</span>
    <span class="o">}</span>

    <span class="n">decode0</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">bits</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span>
  <span class="o">}</span>

  <span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>具体代码见<a href="https://github.com/shunmian/-2_Functional-Programming-in-Scala">这里</a>。</p>

<h2 id="section-4">6 总结</h2>

<p>当<strong>OOP</strong>遇上<strong>λ-Calculus</strong>，Scala给出了自己的实现方案：</p>

<ol>
  <li>万物皆类。<strong>Primitive Data</strong>，<strong>Compound Data</strong>，<strong>Primitive Procedure</strong>，<strong>Compound Procedture(Function)</strong>都是类。</li>
  <li>函数式的体现不仅在于将函数也表示成类，而且在于实现<strong>Data</strong>的时候优先考虑递归和用<strong>Pattern Matching</strong>更方便的将接口实现用于<strong>扩展接口方法</strong>。当然函数式体现还体现在<strong>Data</strong>实现里的immutable特性。</li>
</ol>

<p>最后将本节内容总结成一张图。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-10-04/OOP with λ-Calculus summary.png" alt="OOP with λ-Calculus summary" /></p>

<h2 id="section-5">7 参考资料</h2>
<ul>
  <li><a href="https://mitpress.mit.edu/sicp/full-text/book/book.html">《Structure and Interpretation of Computer Programs》</a>;</li>
  <li><a href="https://www.youtube.com/watch?v=kkTFx3-duc8">Martin Odersky: Scala with Style</a>;</li>
  <li><a href="https://www.youtube.com/watch?v=ecekSCX3B4Q">SF Scala: Martin Odersky, Scala – the Simple Parts</a>;</li>
  <li><a href="https://www.youtube.com/watch?v=v1IlyzxP6Sg">Programming Languages: Lambda Calculus</a>;</li>
  <li><a href="http://www.defmacro.org/ramblings/fp.html">Functional Programming For The Rest of Us</a>;</li>
  <li><a href="http://jim-mcbeath.blogspot.hk/2009/05/scala-functions-vs-methods.html">Scala Functions vs Methods</a>;</li>
</ul>


            <div class="clearfix"></div>
        </div>


    
    <ul class="tag_box list-unstyled list-inline">
      <li><i class="fa fa-folder-open"></i></li>
      
      
      
        <li><a href="http://www.shunmian.me/categories.html#Functional Programming-ref">
          Functional Programming <span>(8)</span>
          
        </a></li>
      
      
    </ul>
    

    
    <ul class="list-inline">
      <li><i class="fa fa-tags"></i></li>
      
      
      
        <li>
          <a href="http://www.shunmian.me/tags.html#OOP&&FP-ref">
          OOP&&FP <span>(5)</span>
          
          </a>
        </li>
      
      
      
    </ul>
    

<hr />
<div >
    <section class="col-sm-7">
        <h4>Share Post</h4>
        <a class="btn btn-default btn-sm" href="http://twitter.com/share?text=FP in Scala(二)：OOP和λ-演算的结合 Part I：万物皆类 && 函数式的体现&via=Wanderl29817400" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fa fa-twitter fa-sm"></i>
        Twitter
        </a>

        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-sm"></i>
          Facebook
        </a>

        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-sm"></i>
          Google+
        </a>
    </section>

    <section class="col-sm-5">
        <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df" class="img-rounded" />
        <h4>Shunmian</h4>
        <p class="author-bio">节物风光不相待，桑田碧海须臾改，唯有美食和code不可辜负。</p>

    </section>

</div>
<div class="clearfix"></div>

<ul class="pager">
    
    <li class="previous"><a href="http://www.shunmian.me/functional%20programming/2015/10/03/Functional-Programming-in-Scala(%E4%B8%80)_%CE%BB-%E6%BC%94%E7%AE%97-Part-III-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE.html" title= "">&larr; Previous</a></li>
    
    
    <li class="next">"<a href="http://www.shunmian.me/functional%20programming/2015/10/05/Functional-Programming-in-Scala(%E4%BA%8C)_OOP%E5%92%8C%CE%BB-%E6%BC%94%E7%AE%97%E7%9A%84%E7%BB%93%E5%90%88-Part-II-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Collection.html" title= "FP in Scala(二)：OOP和λ-演算的结合 Part II：函数式数据结构Collection">Next &rarr;</a></li>
    
</ul>

    <hr />
    
    <section class="comments" style="margin-top:15px;">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'shunmianjohnson'; // required: replace example with your forum shortname
        if(disqus_shortname){
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        }
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </section>
    
    </div>
    <div class="col-sm-1sidebar-2"></div>
    <div class="clearfix"></div>
</article>
<div class="clearfix"></div>


                <div class="footer">
                    <footer>
                        <hr />
                        <p> &copy: 2015 Shunmian with jekyll. Theme: <a href="https://github.com/dbtek/dbyll"dbyll</a> by dbtek.
                        </p>
                    </footer>
                </div>
            </div>
        </div>
    </div>


    <script src="/assets/js/jquery-2.2.0.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript">

$youziku.load(".sidebar_bio", "bdcc72b8235345649b02c123dac5610b", "SiYuan-ExtraLight");


   $youziku.draw();
</script>

</body>

</html>

