<!DOCTYPE html>
<html lang = "en">
<head>
    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/posts/favico/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/posts/favico/favico/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/posts/favico/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/posts/favico/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/posts/favico/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/posts/favico/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/posts/favico/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/posts/favico/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/posts/favico/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/posts/favico/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/posts/favico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/images/posts/favico/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/posts/favico/favicon-16x16.png">
    <link rel="manifest" href="/assets/images/posts/favico/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/images/posts/favico/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">   

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
    <link href="/assets/css/styles.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet' type='text/css'>
<!--     <script type="text/javascript" src="http://api.youziku.com/webfont/FastJS/yzk_976E121ED7CC0870"></script> -->

    <title>SHUNMIAN</title>
</head>


<body>

    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-3 sidebar hidden-xs sidebar">
                
<!--sidebar.html-->
        <header class="sidebar_header " role="banner">
            <a href="http://www.shunmian.me/index.html">
                <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df?s=150" class="img-circle img-responsive center-block sidebar_logo sidebar_img" />
            </a>


            <h3 class="title text-center">
                <a href="http://www.shunmian.me/index.html">SHUNMIAN</a>
            </h3>

        </header>


        <hr class="hr_short"/>
        <div id = "bio" class="text-center sidebar_bio">
            

                <p>嗨，欢迎来到我的博客。<br/>
                我是Shunmian，一名iOS开发者。<br/>
                <hr class = "hr_short_low">
                正在学习Algorithm，Functional Programming，Machine Learning，Data Mining 和 Cloud Computation。 

                </p>

            
        </div>


        <hr class="hr_middle"/>
        <div id = "contact-list" class="text-center">
            <ul class="list-unstyled list-inline">
                <li>
                    
                    <a class="btn btn_info_outline" href="mailto:shunmian@gmail.com"><i class="fa fa-envelope fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-github fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-twitter fa-lg"></i></a>
                    
                </li>

                <li>
                    <a class="btn btn_info_outline" href="http://www.shunmian.me/feed.xml"><i class="fa fa-rss fa-lg"></i></a>
                </li>
        </div>


        <hr class="hr_short"/>
        <div id = "contact-list" class="text-center">
            <ul class="unstyled-list list-inline">
                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/index.html"><i class="fa fa-home fa-md"></i> 主页</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/tags.html"><i class="fa fa-tags fa-md"></i> 标签</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/categories.html"><i class="fa fa-list fa-md"></i> 分类</a>
                </li>
            </ul>
        </div>
        <div class="padding_bottom_500"></div>




<!--sidebar.html end-->

            </div>

            <div class="col-sm-9 col-sm-offset-3">
                

<div class="page-header col-sm-10 col-sm-offset-1">
    <h1 class="article_mainTitle">Algorithm(五)： Graph 图 Part I </h1>
    <span class="post_date">
        2015-09-06 •
    </span>
    <span class="post_category">
        Algorithm
    </span>
</div>

<article class="article">
    <div class="col-sm-10 col-sm-offset-1">
        <div class="article_mainBody">
            <p class="article_content_title">目录</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1 图介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2 图算法</a>    <ul>
      <li><a href="#undirected-graph" id="markdown-toc-undirected-graph">2.1 Undirected Graph</a>        <ul>
          <li><a href="#section-2" id="markdown-toc-section-2">2.1.1 邻接链表实现</a></li>
          <li><a href="#depth-first-search" id="markdown-toc-depth-first-search">2.1.2 Depth-first Search</a></li>
          <li><a href="#breadth-first-search" id="markdown-toc-breadth-first-search">2.1.3 Breadth-first Search</a></li>
          <li><a href="#connected-component" id="markdown-toc-connected-component">2.1.4 Connected Component</a></li>
        </ul>
      </li>
      <li><a href="#directed-graph" id="markdown-toc-directed-graph">2.2 Directed Graph</a>        <ul>
          <li><a href="#section-3" id="markdown-toc-section-3">2.2.1 邻接表实现</a></li>
          <li><a href="#topological-sort" id="markdown-toc-topological-sort">2.2.2 Topological Sort</a></li>
          <li><a href="#cycle-detection" id="markdown-toc-cycle-detection">2.2.3 Cycle Detection</a></li>
          <li><a href="#strong-components" id="markdown-toc-strong-components">2.2.4 Strong Components</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#programming-assignmentwordnet" id="markdown-toc-programming-assignmentwordnet">3 Programming assignment:WordNet</a></li>
  <li><a href="#section-4" id="markdown-toc-section-4">4 参考资料</a></li>
</ul>

<hr class="hr-short-left" />

<h2 id="section">1 图介绍</h2>

<p>在Part I 中，我们介绍了基本的数据结构(<strong>并查集</strong>，<strong>队列</strong> 和 <strong>栈</strong>)，随后又分模块重点介绍了常用的<strong>排序</strong>(<strong>Sorting</strong>)和<strong>查找</strong>（<strong>Searching</strong>）算法和对应的数据结构。在随后的Part II 里，将会着重介绍另外几大类常用的算法，包括<strong>图</strong>算法(<strong>Graph</strong>)，<strong>字符串</strong>算法 (<strong>String</strong>) 和算法周边的知识(<strong>Context</strong>)。本节作为Part II 的开端， 将会介绍Graph的基本知识和一些有趣的实际应用。
此外，在之后的课程中，将会把每周的作业进行解读，提供给感兴趣的同学练练手。这些编程题目深入浅出，把算法和应用紧密结合起来，非常推荐做一下。</p>

<h2 id="section-1">2 图算法</h2>

<h3 id="undirected-graph">2.1 Undirected Graph</h3>

<p><strong>无向图</strong>(<strong>Undirected Graph</strong>)，顾名思义，就是没有方向的边和若干点相互连接形成的拓扑结构。不像前面介绍的排序和查找，我们可以毫不费力地用数组(<strong>Array</strong>)和链表(<strong>List</strong>)将其存储到计算机中，对于图而言，由于连接的多样性，需要谨慎考虑存储在计算机中的方式。先看下Java中Graph类的API:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Graph</span><span class="o">{</span>
                   <span class="n">Graph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">)</span>            <span class="c1">// create a V-vertex graph with no edges</span>
                   <span class="n">Graph</span><span class="o">(</span><span class="n">In</span> <span class="n">in</span><span class="o">)</span>            <span class="c1">// read a graph from input stream in</span>
               <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span>                     <span class="c1">// number of vertices</span>
               <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span>                     <span class="c1">// number of edges</span>
              <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span>   <span class="c1">// add edge v-w to this graph</span>
   <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>            <span class="c1">// vertices adjacent to v</span>
            <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span>              <span class="c1">// string representation</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="section-2">2.1.1 邻接链表实现</h4>
<p>对于Graph API，节点的存储比较好办，只需要申请大小为V的int型数组即可，如果每个节点有额外的信息，也只需要引入在Part I 中介绍的Symbol Table。 但是对于边的话，选择就比较多样了，首先直接想到的是<strong>邻接矩阵</strong>(<strong>Adjacency Matrix</strong>)，但问题是如果图的连接比较稀疏的话，那么矩阵将会变成稀疏矩阵，这对于存储空间是极大的浪费，因此在实际应用中，我们考虑使用<strong>邻接链表</strong>(<strong>Adjacency List</strong>)来实现，如下图所示。</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-06/adjacent-list.png" alt="adjacency-list" /></p>

<p>具体来说，申请一个大小为V的数组，数组的类型是Bag,就像一个袋子一样，不考虑其中元素的顺序，只关心元素是否在袋子里，这样，我们就能通过下标快速地索引到当前节点所有的邻居。以下是Java代码的实现。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UndirectedGraph</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>                    <span class="c1">// number of vertices</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>                          <span class="c1">// number of edges</span>
  <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>             <span class="c1">// adjacency lists</span>
  
  <span class="kd">public</span> <span class="nf">UndirectedGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>                         
      <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>                         
      <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>  <span class="c1">// Create array of lists.</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>         <span class="c1">// Initialize all lists</span>
          <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>    <span class="c1">//   to empty.</span>
   <span class="o">}</span>
  
   <span class="kd">public</span> <span class="nf">UndirectedGraph</span><span class="o">(</span><span class="n">In</span> <span class="n">in</span><span class="o">){</span>
       <span class="k">this</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">());</span>                <span class="c1">// Read V and construct this graph.</span>
       <span class="kt">int</span> <span class="n">E</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>              <span class="c1">// Read E.</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>       
             <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>        <span class="c1">// Read a vertex,</span>
             <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>        <span class="c1">// read another vertex,</span>
             <span class="n">addEdge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>               <span class="c1">// and add edge connecting them.</span>
       <span class="o">}</span>
    <span class="o">}</span>
  
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span>  <span class="o">{</span>  <span class="k">return</span> <span class="n">V</span><span class="o">;</span>  <span class="o">}</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span>  <span class="o">{</span>  <span class="k">return</span> <span class="n">E</span><span class="o">;</span>  <span class="o">}</span>
  
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>
       <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>                     <span class="c1">// Add w to v’s list.</span>
       <span class="n">adj</span><span class="o">[</span><span class="n">w</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>                     <span class="c1">// Add v to w’s list.</span>
       <span class="n">E</span><span class="o">++;</span>
   <span class="o">}</span>
  
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span> 
       <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
   <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>下图是其他两种表示方法的复杂度分析，可见邻接矩阵虽然在查询两个节点是否连接上比较迅速，但是如果要遍历某个给定节点的所有边，复杂度却为O(V)</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/representation.png" alt="representation" /></p>

<h4 id="depth-first-search">2.1.2 Depth-first Search</h4>

<p>还记得特修斯斩杀米诺陶诺斯的故事吗，当时特修斯手持线团和宝剑，冲进迷宫，直接K.O.了迷宫怪牛，然后顺着线团出来了。从小听这个故事就非常好奇特修斯是怎么利用线团来防止迷路的，直到学了无向图中的<strong>深度优先搜索算法</strong>，我才恍然大悟。</p>

<p>问题重现：</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-06/maze.png" alt="maze" /></p>

<p><br /></p>

<blockquote>
  <p>假设特修斯现在在左下角，米诺陶诺斯在中央，特修斯手中有一根无限长的线团，那么他应该采取怎么样的策略才能顺利到达中央并且安全返回。</p>
</blockquote>

<p>不难看出，特修斯可以一股脑一条道走到黑，直到碰到了死胡同，然后顺着线团回头，直到到达最近的交点处，选择另外一条没做过的路继续走到黑。另外如果发现脚下有之前留下的线团，那么立即掉头。大致过程如下所示。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/maze2.png" alt="maze2" /></p>

<p>机智的特修斯真是深谙算法，不过我也纳闷那个时候能找到那么长的线团吗？</p>

<p>下面介绍如何利用深度优先算法实现上述功能，不过在此之前先要阐明一下算法设计的一些理念，众所周知：</p>

<p style="text-align: center;">数据结构 + 算法 = 程序 </p>

<p>在设计图的相关算法的时候也是类似的道理，需要把具体的算法和底层的图结构<strong>解耦</strong>，这样代码维护起来就会非常高效。</p>

<p>在Graph类基础上，我们可以用Graph-Pcocessing来对Graph实例进行处理，这样把Graph和Graph-Processing的好处是可以将Graph(<strong>数据结构</strong>)和图处理(<strong>算法</strong>)解耦。这里我们首先介绍深度优先搜索遍历一个图来获取图中与vertex s连接的vertex v以及具体路径。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstPaths</span><span class="o">{</span>                   <span class="c1">// using depthFirstSearch to find path to s in graph G</span>
   <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>                    <span class="c1">// has dfs() been called for this vertex?</span>
   <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>                        <span class="c1">// last vertex on know path to this vertex</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>                         <span class="c1">// source</span>
   <span class="kd">public</span> <span class="nf">DepthFirstSearchPaths</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
      <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span> 
   <span class="o">}</span>
   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="n">count</span><span class="o">++;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
             <span class="n">edgetTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
             <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
         <span class="o">}</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
       <span class="k">return</span> <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
       <span class="k">if</span><span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
       <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">s</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">x</span><span class="o">])</span>
           <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
       <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>有了上述的算法，我们就可以对给定的Graph和初始节点s，找到与s相连接的所有节点，一旦算法完毕，查询节点是否可达的时间是O(1)的复杂度，而对应的查询源节点s到达任意一点路径的时间正比于路径的长度。</p>

<p>这样，特修斯如果想知道如何从入口s到达迷宫中的任意一点，只需要调用一下<code class="highlighter-rouge">pathTo(int target)</code>方法就搞定，简直是屠牛神器。</p>

<h4 id="breadth-first-search">2.1.3 Breadth-first Search</h4>

<p>与深度优先搜索不同，<strong>广度优先搜索</strong>(<strong>BFS</strong>)更加理智和贪婪，从数据结构的角度出发，广度优先搜索利用的是队列，而不是栈的模型来进行节点的选择。这么做背后的理念就是尽量地保守，不得已的时候才往下探索一层。因此，广度优先搜索有一个非常好的性质，就是能找到从某一源节点到其他节点<strong>最短跳数</strong>的路径，如下图所示。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/BFS.png" alt="Breadth-first Search" /></p>

<p>这种性质使得其使用非常广泛，像好莱坞娱乐圈的<strong>Kevin Bacon Number</strong>以及学术圈的<strong>Erdos Number</strong>，计算的都是以某一节点为中心的最少跳数。下面简要说说Java的实现，与DFS非常类似。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BreadthFirstPaths</span><span class="o">{</span>
   <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>                        <span class="c1">// Is a shortest path to this vertex known?</span>
   <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>                            <span class="c1">// last vertex on known path to this vertex</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">s</span><span class="o">;</span>                             <span class="c1">// source</span>
   <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>                            <span class="c1">// distTo[v] = length of shortest s-&gt;v path</span>

   <span class="kd">public</span> <span class="nf">BreadthFirstPaths</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
      <span class="n">bfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
      <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>                             	<span class="c1">// Mark the source</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>                             	<span class="c1">// and put it on the queue.</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
         <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>                  	 	<span class="c1">// Remove next vertex from the queue.</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">)){</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]){</span>                      	 	<span class="c1">// For every unmarked adjacent vertex,</span>
                <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>                      	<span class="c1">// save last edge on a shortest path,</span>
                <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>                       <span class="c1">// mark it because path is known,</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>                       <span class="c1">// and add it to the queue.</span>
            <span class="o">}</span>
         <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span>  
       <span class="k">return</span> <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>  
   <span class="o">}</span>

   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
       <span class="k">if</span><span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
       <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">s</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">x</span><span class="o">])</span>
           <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
       <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
       <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>for any vertex v reachable from s, BFS computes a shortest path from s to v(no path from s to v has fewer edges).</p>

<h4 id="connected-component">2.1.4 Connected Component</h4>

<p>其实经过了DFS和BFS处理的Graph, <strong>连通分量</strong>(<strong>Connected Component</strong>)的概念就呼之欲出了。因为既然我们已经找出了相互之间可达的节点，那么这些节点不就可以聚为一类吗？而每一类我们就称为<strong>连通分量</strong>。</p>

<p>剩下的问题是，如何找到所有的连通分量，因为如果Graph本身不完全连通，那么一次DFS或者BFS显然是不够的。就像如果怪牛本身就在二楼，特修斯无论怎么找也不可能找到，于是就需要在二楼再来一遍DFS。因此，我们需要对所有节点进行DFS处理，才能找到所有的连通分量。但这样可能带来复杂度的提升，后面我们将会介绍，由于有<code class="highlighter-rouge">marked</code>数组做信息记录，因此这个操作实际上非常快。</p>

<p>还记得本系列的第一篇文章介绍的<strong>并查集</strong>吗,有同学可能会问，既然Union的操作就是添加边的操作，那其实完全可以用并查集来实现连通分量的计算呀，为啥要用DFS和BFS。恩，是的，的确如此，但是，并查集的缺点在于不平衡，即便有很多手段让并查集生成的树尽量平衡，但是依旧不够快。下面，将会基于前文的DFS向大家介绍一种非常高效的连通分量查找算法。代码如下。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CC</span><span class="o">{</span>

   <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
   
   <span class="kd">public</span> <span class="nf">CC</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">){</span>
      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">s</span><span class="o">++)</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]){</span>
             <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
             <span class="n">count</span><span class="o">++;</span> 
        <span class="o">}</span>
   <span class="o">}</span>
   
   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span><span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>  
       <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">id</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>  
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>  <span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>  <span class="o">}</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span>   <span class="o">{</span>  <span class="k">return</span> <span class="n">count</span><span class="o">;</span>  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>可见， CC类中扩展了DFS的方法，唯一不同的是遍历调用了<code class="highlighter-rouge">dfs</code>函数，和并查集比起来，最后生成的其实是一棵扁平化的并查集树，时间复杂度固然高效O(1)。</p>

<p>寻找连通分量在实际中的应用也是非常广泛，例如在星空背景下的一颗颗星星，就可以看出一个个的连通分量，另外熟悉Photoshop的同学应该知道有一种flood fill技巧，如下图泰姬陵的天空一样进行局部的颜色修改，却不影响边界的颜色。这里的原理就是把颜色相近的像素看成连通，而边缘的阶跃看成不连通，这样只要找出连通分量，就能把边缘勾勒出来，非常的巧妙。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/flood fill.png" alt="Flood fill" /></p>

<p>像素放大后的效果:</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-06/flood fill2.png" alt="Flood fill2" /></p>

<h3 id="directed-graph">2.2 Directed Graph</h3>

<p><strong>有向图</strong>(<strong>Directed Graph</strong>)比起无向图来情况复杂很多，因为限制更加严格，由双向车道一下子变成单行线，衍生出来的问题也非常多，比如强连通分量，最短路径，拓扑排序等等。下面将会一一介绍这些算法和性质。</p>

<h4 id="section-3">2.2.1 邻接表实现</h4>
<p>在此之前，首先还是介绍一下有向图的存储和API。和无向图相似，有向图的存储也使用邻接链表的方式，不同的是这个时候的边有方向，因此原来无向图中同一条边需要存两次，在有向图中值需要存一次，其他的基本一致，java代码中类名由<code class="highlighter-rouge">Graph</code>变成<code class="highlighter-rouge">Digraph</code>即可。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Digraph</span><span class="o">{</span>
     <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>
     <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>
     <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>
     
     <span class="kd">public</span> <span class="nf">Digraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">){</span>           <span class="c1">//create a V-vertex digraph with no edges</span>
        <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
           <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
     <span class="o">}</span>
     
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span>  <span class="o">{</span>  <span class="k">return</span> <span class="n">V</span><span class="o">;</span>  <span class="o">}</span>      <span class="c1">//number of vertices</span>
     <span class="kd">public</span> <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span>  <span class="o">{</span>  <span class="k">return</span> <span class="n">E</span><span class="o">;</span>  <span class="o">}</span>      <span class="c1">//number of edges</span>
     
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>     <span class="c1">//add edge v-&gt;w to this digraph</span>
        <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
        <span class="n">E</span><span class="o">++;</span>
     <span class="o">}</span>
     
     <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span>  
      <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>  <span class="o">}</span>
     
     <span class="kd">public</span> <span class="n">Digraph</span> <span class="nf">reverse</span><span class="o">(){</span>          <span class="c1">//reverse of this Digraph</span>
        <span class="n">Digraph</span> <span class="n">R</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Digraph</span><span class="o">(</span><span class="n">V</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
           <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
              <span class="n">R</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">R</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>另外，<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>同样适用于有向图，不同之处在于</p>

<ol>
  <li>深度优先搜索侧重的是<strong>可达性</strong>分析，也就是说，从给定的一点出发，是否能经过一系列的路径到达指定的一点。在实际应用中这种情况大范围存在，比如<strong>程序控制分析</strong>(<strong>program control-flow analysis</strong>)和<strong>标记-清理式垃圾回收器</strong>(<strong>mark-sweep garbage collector</strong>)。大家可能会问，为什么在介绍无向图的时候没有那么多的应用，原因很简单，现实生活中的很多应用都是有向图。</li>
  <li>广度优先搜索侧重的是多源节点的广度搜索，做法和单元节点比较起来，只需要在初始化的时候把所有源节点压入队列即可，非常elegant。另外有向图的BFP在<strong>网略爬虫</strong>(<strong>Web Crawler</strong>)中有大量应用。以上问题和无向图类似，下面介绍若干有向图特有的性质和问题。</li>
</ol>

<h4 id="topological-sort">2.2.2 Topological Sort</h4>

<p><strong>拓扑序(Topological Sort)</strong>是有向图中特殊的一种性质，并且要求进一步提高，不仅要求是有向，而且必须<strong>没有环</strong>，这就是传说中的<strong>DAG(Directed Acyclic Graph)有向无环图</strong>。这里没有环的意思是从任意一点找不到任何路径可以回到自身。这个要求相当严格，可以想象，如果满足以上性质，那么整个DAG可以拉长成一条线，有严格的先后顺序，这就是<strong>拓扑序</strong>，就像下图所示:</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/Topological sort2.png" alt="Topological sort" /></p>

<p>那么问题来了，既然一个DAG必然存在拓扑序，那么怎么设计算法高效的找出整个拓扑序呢。令人吃惊的是，寻找拓扑序的算法异常的简单，只需要在DAG上跑若干遍DFS算法，然后把访问的节点后序压栈(Post)，最后所有跑完所有DFS后，依次弹栈的顺序就是拓扑序的顺序。</p>

<ol>
  <li>Run depth-first search</li>
  <li>Return vertices in reverse postorder</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DepthFirstOrder</span><span class="o">{</span>
  
   <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>
   <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pre</span><span class="o">;</span>          <span class="c1">// vertices in preorder</span>
   <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">post</span><span class="o">;</span>         <span class="c1">// vertices in postorder</span>
   <span class="kd">private</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">reversePost</span><span class="o">;</span>  <span class="c1">// vertices in reverse postorder</span>
   
   <span class="kd">public</span> <span class="nf">DepthFirstOrder</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">){</span>
      <span class="n">pre</span>           <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="n">post</span>          <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="n">reversePost</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="n">marked</span>  <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
      <span class="n">pre</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
      <span class="n">post</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
      <span class="n">reversePost</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pre</span><span class="o">(){</span><span class="k">return</span> <span class="n">pre</span><span class="o">;}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">post</span><span class="o">(){</span><span class="k">return</span> <span class="n">post</span><span class="o">;}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">reversePost</span><span class="o">(){</span><span class="k">return</span> <span class="n">reversePost</span><span class="o">;}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>还不服？下面证明一下，考虑存在一条从v到w的边，即<em>v-&gt;w</em>，根据上述算法，研究当调用<code class="highlighter-rouge">dfs(v)</code>的一瞬间发生了什么:</p>

<ol>
  <li><code class="highlighter-rouge">dfs(w)</code>已经被调用并且返回，这种情况发生在除了v之外还有其他的边指向w，如<em>u-&gt;w</em>，并且调用<code class="highlighter-rouge">dfs(u)</code>完毕，已经返回，则必然此时<code class="highlighter-rouge">dfs(w)</code>也已经返回。在这种情况下，w在v之前被压入栈中，最后弹栈时必然v在w前面，符合实际的v-&gt;w。</li>
  <li><code class="highlighter-rouge">dfs(w)</code>还没有被调用，容易知道这种情况下w将会在调用<code class="highlighter-rouge">dfs(v)</code>后递归调用到<code class="highlighter-rouge">dfs(w)</code>，最后也是当<code class="highlighter-rouge">dfs(w)</code>返回后<code class="highlighter-rouge">dfs(v)</code>才能返回。这种情况下w依旧在v之前被压入栈中。</li>
  <li><code class="highlighter-rouge">dfs(w)</code>被调用了，，但是还没有返回，这种情况不可能发生，因为如果上述情况发生，就意味着<code class="highlighter-rouge">dfs(w)</code>在等待<code class="highlighter-rouge">dfs(v)</code>的返回，即存在一条边<em>w-&gt;v</em>,而这样，v和w酒构成了一个环，违反了DAG的设定。</li>
</ol>

<p>综上所述，算法正确，只要存在<em>v-&gt;w</em>，那么出栈顺序中v也一定在w前面。</p>

<p>是不是已经晕了，没事儿，只要记住结论:</p>

<blockquote>
  <p>对DAG图上所有未标记的节点跑DFS算法，并且采用ReversePost方式压栈，最后一次出栈的顺序就是拓扑序。</p>
</blockquote>

<h4 id="cycle-detection">2.2.3 Cycle Detection</h4>

<p>DFS的用处远不止如此，另一个重要应用就是用于检测有向图中的环，换句话说，一个有向图，要么是DAG，要么就存储在环，二选一。</p>

<p>这里的原理就是对DFS搜索路径上的所有节点进行标记，若果在某一个的递归中，发了援救标记的节点，说明存在路径到达了自身，这个就像贪吃蛇一样碰到了自己的身子，接下来的就是记录环的情况，然后函数返回。关键代码如下。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>  
    <span class="n">onStack</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">w:</span><span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">)){</span>
        <span class="c1">//已经有环了，洗洗睡吧</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cycle</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="c1">//未访问过则继续往下探索</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]){</span>
            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span><span class="n">w</span><span class="o">);</span>
        <span class="c1">//访问过并且处于当前DFS路径，有环！</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="n">onStack</span><span class="o">[</span><span class="n">w</span><span class="o">]{</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
            <span class="c1">//记录环的情况</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">v</span><span class="o">;</span><span class="n">x</span><span class="o">!=</span><span class="n">w</span><span class="o">;</span><span class="n">x</span><span class="o">=</span><span class="n">edgeTo</span><span class="o">[</span><span class="n">x</span><span class="o">])</span>
                <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="n">cycle</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">//当前节点搜索完毕，换一条路径</span>
    <span class="n">onStack</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span><span class="kc">false</span><span class="o">;</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="strong-components">2.2.4 Strong Components</h4>

<p>有向图的<strong>强连通分量</strong>(<strong>Strong Components</strong>)对应于无向图的连通分量，也具有相等关系的性质，具体来说，满足一下3个特性:</p>

<ol>
  <li>v is strongly connected to V（自反性）；</li>
  <li>if v is strongly connected to w, then w is strongly connected to v（对称性）；</li>
  <li>if v is strongly connecte to w, and w to x, then v is strongly connected to x（传递性）.</li>
</ol>

<p>而前面介绍的有向图的<strong>可达性</strong>，并不满足对称性。Java中强连通分量的API接口和无向图的连通分量一样:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="c1">// components in undirected graph</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">connected</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>  
    <span class="k">return</span> <span class="n">cc</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">cc</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>
<span class="o">}</span>

<span class="c1">// strong components in directed graph</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">stronglyConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>  
    <span class="k">return</span> <span class="n">scc</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">scc</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>可见一旦算法结束，查询连通分量的效率是妥妥的常数时间，那么，究竟该如何计算一个有向图的强连通分量呢?</p>

<p>有意思的是，历史上搜索强连通分量的算法发展历经坎坷，下面介绍一种1980s年的<strong>Kosaraju-Sharir算法</strong>，该算法看起来非常简单，正确性的证明却非常需要技巧，算法一共分为两步:</p>

<ol>
  <li>计算对称图中Kernel DAG的拓扑顺序(compute reverse postorder in G<sup>R</sup>);</li>
  <li>根据拓扑序一次对各节点调用DFS,没调用一次DFS，生成一个Strong component。</li>
</ol>

<p>以上算法非常巧妙，结合了拓扑序和DFS，而计算拓扑序实际上也是DFS,因此KS算法可以总结为<strong>两轮DFS</strong>。具体代码如下，和前面无向图计算连通分量非常相似。</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-06/Strong Connectivity.png" alt="Connectivity" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KosarajuSharirSCC</span><span class="o">{</span>
  
  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>     <span class="c1">//reached vertices</span>
  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">id</span><span class="o">;</span>             <span class="c1">//component identifiers</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>            <span class="c1">//number of strong components</span>

  <span class="kd">public</span> <span class="nf">KosarajuSharirSCC</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">){</span>
    <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">DepthFirstOrder</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DepthFirstOrder</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">reverse</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">:</span> <span class="n">order</span><span class="o">.</span><span class="na">reversePost</span><span class="o">())</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]){</span>  
        <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span> <span class="n">count</span><span class="o">++;</span>
      <span class="o">}</span>
  <span class="o">}</span>
  
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
       <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
       <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span>
              <span class="n">dfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">stronglyConnected</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span><span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">id</span><span class="o">[</span><span class="n">w</span><span class="o">];}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span><span class="k">return</span> <span class="n">id</span><span class="o">[</span><span class="n">v</span><span class="o">];}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">(){</span><span class="k">return</span> <span class="n">count</span><span class="o">;}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>这里调用了前面Topological Sort的<code class="highlighter-rouge">DepthFirstOrder</code>类，然后修改了一下类名，就形成了新的<code class="highlighter-rouge">KosarjuShairSCC</code>类。关于正确性的证明，参考一下前面拓扑序的证明就可以感受一下KS算法证明的复杂性。大家需要知道的一点是，原始图G和对称图G<sup>R</sup>的连通分量完全一致，因此对称图中利用后续压栈的方法能到不到不同连通分量之间的拓扑顺序。然后为了从拓扑序的末端开始往上游延伸，故子第一部选择在对称图进行Kernel DAG的拓扑序查找。因此，强连通分量算法最牛掰的地方是能把任意有向图转化为<strong>Kernel DAG</strong>图，许多算法都要基于此进行，一般都是在不同的连通分量上进行算法设计，最终把各连通分量的结果合并即可。</p>

<p>至此，关于有向图，我们介绍了<strong>可达性分析(DFS)</strong>，<strong>拓扑排序(DFS)</strong>，<strong>有向环检测(DFS)</strong>，和<strong>强连通分量(2*DFS)</strong>。可见随处都是DFS，我们是彻彻底底地和DFS杠上了。相比之下，BFS的应用主要在<strong>最短跳数</strong>的求解上，希望以上的概括能给大家理解DFS和BFS一个比较好的直观感受。</p>

<h2 id="programming-assignmentwordnet">3 Programming assignment:WordNet</h2>

<p>本次的编程作业一如既往的有意思，核心任务主要是：</p>

<blockquote>
  <p>在WordNet上面构建一个有向图，要求计算出任意给定两个点的最短距离，如果没有直接可达的路径，则计算出距离最近的共同祖先节点的距离和，否则返回-1。</p>
</blockquote>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/wordnet.png" alt="wordnet" /></p>

<p>举个例子详细说明一下题目的要求，比如上述的一个<strong>有向无环图(DAG)</strong>，中间的<strong>miracle</strong>和最右边的<strong>group_action</strong>，有共同的祖先<strong>event</strong>，故他们的最短距离为2，同理可以计算出任意两个节点之间的最短距离。重写BFS，需要对BFS的算法有较深入的理解：</p>

<ol>
  <li>包括为什么使用队列而不是栈（队列可以保证逐层遍历）；</li>
  <li>如果v和x在同一层，并且同时有v-&gt;w和x-&gt;y-w,那么w是在v和x的下一层还是下两层(下一层，因为逐层遍历，w作为v的邻居先被压入队列，marked[w]已经true，通过x-&gt;y-&gt;w已经访问不到w)；</li>
  <li>“多源节点的广度搜索，做法和单元节点比较起来，只需要在初始化的时候把所有源节点压入队列即可，非常elegant”。这句话如何理解(可以将多源节点想象成虚拟单节点的邻居，这就退化成了单节点的BFS问题，而单节点的BFS问题第一步就是将多源节点压入队列)。</li>
</ol>

<p>因此，概括一下对于DAG的情况下最短距离的思路：</p>

<ol>
  <li>将初始的集合(或者单节点)分别压入两个队列vQueue和wQueue；</li>
  <li>利用这两个队列分别同时进行广度优先搜索，也就是说，两个队列的搜索深度同步递增；</li>
  <li>循环2，知道其中一组遇到对方标记过的节点，算法终止，这个时候查看对方标记的节点的深度值depthW，再加上自己搜索到此的深度值depthV，得到深度值总和，就是最短距离。</li>
</ol>

<p>注意一下，上面的算法是针对<strong>DAG</strong>的，也就是说没有环，因此我们在第一次遇到之后就可以终止算法，但是，这题的输入是<strong>不限于DAG</strong>的。</p>

<p>题目要求实现三个类：</p>

<ol>
  <li>SAP.java;</li>
  <li>WordNet.java;</li>
  <li>Outcast.java;</li>
</ol>

<p>题目假定输入的有向图是任意的有向图，也就意味着可能是<strong>有环的</strong>，<strong>不连通的</strong>，甚至有<strong>多个根节点</strong>，这里的根节点其实就是WordNet里面的叶子节点，理论上所有的WordNet最终都指向一个节点<strong>Entity</strong>。这里的核心两个算法如下：</p>

<ol>
  <li>如何高效计算任意一个有向图的任意两个结合(或者一对节点)间最短距离；</li>
  <li>如何能检测出一个有向图是<strong>有环的</strong>，<strong>不连通的</strong>，甚至有<strong>多个根节点</strong>。</li>
</ol>

<p>第一个的思路也非常简单，是基于上述基本版本的改进版。既然可能存在环，那么我们就不能一遇到对方的标记的节点就终止算法，而是应该把这个时候计算得到的深度总和记录下来，形成一个record，形式为&lt;vertextID,vertexDepth&gt;。这样，当两个BFS都搜索完毕时，对比所有的record，找到一个depth最短的，返回即可。</p>

<p>这样做的确能保证算法的正确性，但是仔细一想，假设当前已经找到了一个被标记的节点深度总和为5，而当前两个BFS的搜索迭代到了第8层，那么我们还有迭代下去的必要吗？答案很显然，没有必要，因为哪怕本次迭代又找到了一个被标记的节点，充其量最短距离也不会小于8。这启发我们在BFS的时候可以进行early stopping。思路是在本次迭代搜索开始前，先对比搜索深度是否已经超过了目前已知的最短deDepth记录，如果超过那么直接结束了迭代。</p>

<p>第二个问题可以拆分为三个小问题:</p>

<ol>
  <li>判断有向图有环的方法是在进行DFS的时候维护一条当前搜索链，当发现某一次搜索重新探测到了已经被标记为当前搜索链的节点，那么必然存在一个环。</li>
  <li>判断是否连通最简单的方法就是转换为无向图然后进行BFS或者DFS，看最后的连通分量的数量。</li>
  <li>判断是否有多个WordNet根节点只需要统计每个节点的<strong>出度(Outdegree)</strong>，任何出度为0的丢失WordNet根节点。</li>
</ol>

<p>克服了以上两个核心问题，剩下的就是慢慢抠细节了，详细的代码，Specification和CheckLisk及test file在<a href="https://github.com/shunmian/Algorithm-II/tree/master/Week1_WordNet">这里</a>。</p>

<p>最后贴一个跑分表，竟然超过了100分，貌似时间比较快，有奖励…</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/assessment.png" alt="assessment" /></p>

<h2 id="section-4">4 参考资料</h2>
<ul>
  <li>
    <p><a href="http://algs4.cs.princeton.edu/home/">Algorithm</a>;</p>
  </li>
  <li>
    <p><a href="http://visualgo.net/">Visualize Algorithm</a>;</p>
  </li>
  <li>
    <p>本文转自<a href="http://aaronxic.com/algorithms-graph-i/#.Vxy4lKNcSko">[ALGORITHMS] GRAPHS (I)</a>;</p>
  </li>
</ul>


            <div class="clearfix"></div>
        </div>


    
    <ul class="tag_box list-unstyled list-inline">
      <li><i class="fa fa-folder-open"></i></li>
      
      
      
        <li><a href="http://www.shunmian.me/categories.html#Algorithm-ref">
          Algorithm <span>(7)</span>
          
        </a></li>
      
      
    </ul>
    

    
    <ul class="list-inline">
      <li><i class="fa fa-tags"></i></li>
      
      
      
        <li>
          <a href="http://www.shunmian.me/tags.html#Graph-ref">
          Graph <span>(2)</span>
          
          </a>
        </li>
      
      
      
    </ul>
    

<hr />
<div >
    <section class="col-sm-7">
        <h4>Share Post</h4>
        <a class="btn btn-default btn-sm" href="http://twitter.com/share?text=Algorithm(五)： Graph 图 Part I&via=Wanderl29817400" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fa fa-twitter fa-sm"></i>
        Twitter
        </a>

        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-sm"></i>
          Facebook
        </a>

        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-sm"></i>
          Google+
        </a>
    </section>

    <section class="col-sm-5">
        <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df" class="img-rounded" />
        <h4>Shunmian</h4>
        <p class="author-bio">节物风光不相待，桑田碧海须臾改，唯有美食和code不可辜负。</p>

    </section>

</div>
<div class="clearfix"></div>

<ul class="pager">
    
    <li class="previous"><a href="http://www.shunmian.me/algorithm/2015/09/05/Algorithm(%E4%BA%94)_Searching-%E6%90%9C%E7%B4%A2.html" title= "">&larr; Previous</a></li>
    
    
    <li class="next">"<a href="http://www.shunmian.me/algorithm/2015/09/07/Algorithm(%E4%BA%94)_Graph-%E5%9B%BE-part-II.html" title= "Algorithm(五)： Graph 图 Part II">Next &rarr;</a></li>
    
</ul>

    <hr />
    
    <section class="comments" style="margin-top:15px;">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'shunmianjohnson'; // required: replace example with your forum shortname
        if(disqus_shortname){
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        }
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </section>
    
    </div>
    <div class="col-sm-1sidebar-2"></div>
    <div class="clearfix"></div>
</article>
<div class="clearfix"></div>


                <div class="footer">
                    <footer>
                        <hr />
                        <p> &copy: 2015 Shunmian with jekyll. Theme: <a href="https://github.com/dbtek/dbyll"dbyll</a> by dbtek.
                        </p>
                    </footer>
                </div>
            </div>
        </div>
    </div>


    <script src="/assets/js/jquery-2.2.0.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

    <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    <script type="text/javascript">

$youziku.load(".sidebar_bio", "bdcc72b8235345649b02c123dac5610b", "SiYuan-ExtraLight");


   $youziku.draw();
</script>

</body>

</html>

