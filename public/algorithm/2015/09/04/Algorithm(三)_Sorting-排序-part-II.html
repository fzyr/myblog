<!DOCTYPE html>
<html lang = "en">
<head>
    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/posts/favico/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/posts/favico/favico/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/posts/favico/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/posts/favico/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/posts/favico/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/posts/favico/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/posts/favico/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/posts/favico/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/posts/favico/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/posts/favico/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/posts/favico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/images/posts/favico/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/posts/favico/favicon-16x16.png">
    <link rel="manifest" href="/assets/images/posts/favico/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/images/posts/favico/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">   

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
    <link href="/assets/css/styles.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet' type='text/css'>
<!--     <script type="text/javascript" src="http://api.youziku.com/webfont/FastJS/yzk_976E121ED7CC0870"></script> -->

    <title>SHUNMIAN</title>
</head>


<body>

    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-3 sidebar hidden-xs sidebar">
                
<!--sidebar.html-->
        <header class="sidebar_header " role="banner">
            <a href="http://www.shunmian.me/index.html">
                <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df?s=150" class="img-circle img-responsive center-block sidebar_logo sidebar_img" />
            </a>


            <h3 class="title text-center">
                <a href="http://www.shunmian.me/index.html">SHUNMIAN</a>
            </h3>

        </header>


        <hr class="hr_short"/>
        <div id = "bio" class="text-center sidebar_bio">
            

                <p>嗨，欢迎来到我的博客。<br/>
                我是Shunmian，一名iOS开发者。<br/>
                <hr class = "hr_short_low">
                正在学习Algorithm，Functional Programming，Machine Learning，Data Mining 和 Cloud Computation。 

                </p>

            
        </div>


        <hr class="hr_middle"/>
        <div id = "contact-list" class="text-center">
            <ul class="list-unstyled list-inline">
                <li>
                    
                    <a class="btn btn_info_outline" href="mailto:shunmian@gmail.com"><i class="fa fa-envelope fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-github fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-twitter fa-lg"></i></a>
                    
                </li>

                <li>
                    <a class="btn btn_info_outline" href="http://www.shunmian.me/feed.xml"><i class="fa fa-rss fa-lg"></i></a>
                </li>
        </div>


        <hr class="hr_short"/>
        <div id = "contact-list" class="text-center">
            <ul class="unstyled-list list-inline">
                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/index.html"><i class="fa fa-home fa-md"></i> 主页</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/tags.html"><i class="fa fa-tags fa-md"></i> 标签</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/categories.html"><i class="fa fa-list fa-md"></i> 分类</a>
                </li>
            </ul>
        </div>
        <div class="padding_bottom_500"></div>




<!--sidebar.html end-->

            </div>

            <div class="col-sm-9 col-sm-offset-3">
                

<div class="page-header col-sm-10 col-sm-offset-1">
    <h1 class="article_mainTitle">Algorithm(三)： Sorting 排序 part II </h1>
    <span class="post_date">
        2015-09-04 •
    </span>
    <span class="post_category">
        Algorithm
    </span>
</div>

<article class="article">
    <div class="col-sm-10 col-sm-offset-1">
        <div class="article_mainBody">
            <p class="article_content_title">目录</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">2. 排序算法</a>    <ul>
      <li><a href="#section-1" id="markdown-toc-section-1">2.5 快速排序</a>        <ul>
          <li><a href="#way-quick-sort" id="markdown-toc-way-quick-sort">2.5.1 2-way Quick Sort</a></li>
          <li><a href="#way-quick-sort-1" id="markdown-toc-way-quick-sort-1">2.5.2 3-way Quick Sort</a></li>
          <li><a href="#system-quick-sort" id="markdown-toc-system-quick-sort">2.5.3 System Quick Sort</a></li>
          <li><a href="#selection-problem" id="markdown-toc-selection-problem">2.5.4 Selection Problem</a></li>
          <li><a href="#java-implementation" id="markdown-toc-java-implementation">2.5.5 Java Implementation</a></li>
        </ul>
      </li>
      <li><a href="#heap-sort" id="markdown-toc-heap-sort">2.6 Heap Sort</a>        <ul>
          <li><a href="#elementary-implementation" id="markdown-toc-elementary-implementation">2.6.1 Elementary Implementation</a></li>
          <li><a href="#binary-heap-implementation" id="markdown-toc-binary-heap-implementation">2.6.2 Binary Heap Implementation</a>            <ul>
              <li><a href="#binary-tree" id="markdown-toc-binary-tree">2.6.2.1 Binary Tree</a></li>
              <li><a href="#binary-heap" id="markdown-toc-binary-heap">2.6.2.2 Binary Heap</a></li>
              <li><a href="#sorting" id="markdown-toc-sorting">2.6.2.3 Sorting</a></li>
              <li><a href="#build-heap" id="markdown-toc-build-heap">2.6.2.3.1 Build Heap</a></li>
              <li><a href="#sortdown" id="markdown-toc-sortdown">2.6.2.3.2 Sortdown</a></li>
              <li><a href="#mathmatics-analysisa" id="markdown-toc-mathmatics-analysisa">2.6.2.3.2 Mathmatics Analysis&lt;/a&gt;</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#section-2" id="markdown-toc-section-2">3 总结</a></li>
  <li><a href="#section-3" id="markdown-toc-section-3">4 参考资料</a></li>
</ul>

<hr class="hr-short-left" />

<h2 id="section">2. 排序算法</h2>

<p>紧接part，下面介绍另外几种排序算法。</p>

<h3 id="section-1">2.5 快速排序</h3>

<h4 id="way-quick-sort">2.5.1 2-way Quick Sort</h4>

<p><strong>快速排序(Quick Sort)</strong>最早由<strong>Antony Hoare</strong>(1980年图灵奖获得者)提出，算法的思想和归并排序一样，也是分而治之的方法。具体来说，对于选定的元素pivot(中心点)，通过不停地交换，使得pivot落到最终顺序的对应位置上，并且保证这个时候<strong>左边的所有元素不大于pivot，右边的所有元素不小于pivot</strong>。至此，就把原来的问题划分为两个子问题，再递归地左右两个子问题进行排序。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-04/2-way Quick Sort.png" alt="2-way Quick Sort" /></p>

<p>为了上述的步骤，首先需要确定pivot的选取方法，一种常用的方法是直接选取待排数组的第一个元素，即<code class="highlighter-rouge">pivot = a[lo]</code>。如上图所示，第一次迭代选取8作为pivot，然后不停交换元素使得8落到对应的正确的位置上，同时把数组划分为两半，分别递归地对两个子问题进行求解，得到最终结果。</p>

<p>完整的Java代码如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><pre>    
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">QuickSort</span> <span class="o">{</span>    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">){</span>
        <span class="n">StdRandom</span><span class="o">.</span><span class="na">shuffle</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">hi</span> <span class="o">&lt;=</span> <span class="n">lo</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">lo</span><span class="o">,</span><span class="n">hi</span><span class="o">);</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">hi</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>    <span class="c1">//刚开始从数组第一个元素开始partition</span>
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">a</span><span class="o">[++</span><span class="n">i</span><span class="o">],</span><span class="n">v</span><span class="o">))</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">hi</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">while</span><span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">a</span><span class="o">[--</span><span class="n">j</span><span class="o">]))</span> <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">lo</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">exchange</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">exchange</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">lo</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>细心的朋友应该会发现在上述Java的实现中，排序前进行了Shuffle，<strong>为什么要这么做呢？</strong>首先让我们分析一下最坏情况下快速排序的时间复杂度。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-04/2-way Quick Sort cases.png" alt="2-way Quick Sort cases" /></p>

<p>如上图所示，（a）为最好情况，(c)为最差情况，(b)为平均情况。在最差情况下，每次选取的pivot在划分后非常不幸都会出现一个<strong>空的子问题</strong>，数组长度缓慢缩短，因此这个情况下的时间复杂度为：</p>

<p style="text-align: center;">
N + (N-1) + ... + 1 ~ 1/2 * N<sup>2</sup>
</p>

<p>当N非常大的时候，这是无法忍受的，因此为了避免上述情况，我们采取洗牌的策略，无论输入的序列如何，我们都能在O(N)的时间内完成洗牌操作，然后再近些快速排序。但是完美主义者不高兴了，即便洗牌也会出现最坏情况呀，打麻将一摸牌就胡的也有呀…Calm Down，当N很大的时候，这个概率比此时此刻坐在电脑前的你被雷劈的概率还要小，所以，大可放心…</p>

<p>下面分析一下快速排在在平均情况下的时间复杂度。</p>

<p>我们采取递推的方法，由快速排序的算法过程我们可以得出以下递推关系：</p>

<p style="text-align: center;">
C<sub>N</sub> = (N + 1) + 1/N * [(C<sub>0</sub> + C<sub>N-1</sub>) + ... + (C<sub>N-1</sub> + C<sub>0</sub>)]
</p>

<p>其中N+1是在partition操作中的比较次数，分式1/N是每种情况发生的概率。求解上述递推，左右乘以N，并且进行逐差，可以得到</p>

<p style="text-align: center;">
C<sub>N</sub>/N+1 -  C<sub>N-1</sub>/N = 2/N+1
</p>

<p>结合出项C<sub>0</sub> = C<sub>1</sub> = 0， N ≥ 2，错位相消后得到：</p>

<p style="text-align: center;">
C<sub>N</sub> = 2(N + 1)(1/3 + 1/4 + ... + 1/N+1) ~ 2(N + 1)lnN ≈ 2NlnN
</p>

<p>又因为</p>
<p style="text-align: center;">
2NlnN = 2N(lgN/lge) = 2N * ln2 * lgN = 1.39NlgN
</p>

<p>因此可见快速排序实际上比归并排序要多39%的比较次数，但是在实际中却快于归并排序，因为快速排序涉及的元素比归并排序少。</p>

<h4 id="way-quick-sort-1">2.5.2 3-way Quick Sort</h4>

<p>上面介绍的是2-way的方法，也就是分成两部分，如下图所示</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-04/2-way Quick Sort2.png" alt="2-way Quick Sort2" /></p>

<p>但是，当数组存在大量的<strong>重复键值(Duplicate Keys)</strong>的时候，这些重复的键值会不管的出现在子问题中，使得数组长度的减少类似worst-case一样缓慢，这个时候的复杂度为O(N<sup>2</sup>)。这里八卦一些野史，就是说自从c语言的<code class="highlighter-rouge">qsort()</code>出来蛮长的一段时间后，来自AT&amp;T Bell Lab(1991)的<strong>Allan Wilks</strong>和<strong>Rick Recker</strong>发现本来一个瞬间排序结束的<code class="highlighter-rouge">qsort()</code>却需要好几分钟，后来人们才意识到了qsort()对于重复键值处理得非常糟糕，后来就诞生了额下面将要介绍的3-way方法，如下图所示。</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-04/3-way Quick Sort.png" alt="3-way Quick Sort" /></p>

<p>Java 代码如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="o">){</span>  
    <span class="k">if</span><span class="o">(</span><span class="n">lo</span><span class="o">&gt;=</span><span class="n">hi</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">lt</span><span class="o">=</span><span class="n">lo</span><span class="o">,</span><span class="n">gt</span><span class="o">=</span><span class="n">hi</span><span class="o">;</span>
    <span class="n">Comparable</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">lo</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">gt</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lt</span><span class="o">++,</span> <span class="n">i</span><span class="o">++);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">exch</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">gt</span><span class="o">--);</span>
        <span class="k">else</span> <span class="n">i</span><span class="o">++;</span> 
    <span class="o">}</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">lt</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">sort</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">gt</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
<span class="o">}</span> <span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="system-quick-sort">2.5.3 System Quick Sort</h4>

<p>作为目前最重要的一种算法之一，快速排序的性能已经得到了极大的优化，一般来说，工业级别的快速排序遵循以下几个原则：</p>

<ul>
  <li>对于规模较小的数组(长度不大于8)，使用插入排序取代；</li>
  <li>Partition的时候用3-way Partition；</li>
  <li>对于Pivot的选择：小型规模数组，中间项；中型规模数组：取任意3个元素的中位数；大型规模数组：<strong>Tukey’s ninther</strong>(Median of median of 3 samples, each of 3 entries)。</li>
</ul>

<p>还及得温州一开始提到的信息论角度理解Comparison Sort吗？不过规模数组下的Pivot选择的策略不一样，亩的就是尽可能的让Pivot大概率选取到中位数，因为如果Pivot恰好是中位数，就正好*等分**数组，使得获取的信息量最大。</p>

<h4 id="selection-problem">2.5.4 Selection Problem</h4>

<p>在实际应用中，往往需要找出排在第k位的元素是多少，这类问题统一归类为<strong>Selection Problem选择问题</strong>。这类问题有显而易见的上界和下界：</p>

<ul>
  <li>
    <p>Upper bound，如果先对数组进行排序，然后直接访问数组中对应的位置，就能解决Selection问题，这样复杂度为O(NlogN);</p>
  </li>
  <li>
    <p>Lower bound，易知无论用何种算法，至少需要对所有的数据扫描一遍，因此下界就很容易确定下来，为Ω(N)。</p>
  </li>
</ul>

<p>下面介绍一种介于快速排序思想的方法，<strong>Quick Selection</strong>，这种算法能在平均情况下达到线性，也就是说，把Upper bound进一步降低至O(N)，这样就得到Selection的渐进复杂度Θ(N)。代码如下</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="n">Comparable</span> <span class="nf">select</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>  
    <span class="n">StdRandom</span><span class="o">.</span><span class="na">shuffle</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">lo</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">hi</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span><span class="o">(</span><span class="n">hi</span><span class="o">&gt;</span><span class="n">lo</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">];</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="java-implementation">2.5.5 Java Implementation</h4>
<p>前文提到了Java中在调用<code class="highlighter-rouge">Arrays.sort()</code>函数时，Java会更具传入的数据类型使用归并排序或者快速排序。</p>

<ul>
  <li>如果传入的是Object类型，那么Java会使用归并排序；</li>
  <li>如果传入的原始类型(int，double等)，Java会调用快速排序。</li>
</ul>

<p>这么做的逻辑是常若用户传入的是Object，说明用户对于内存空间并不在乎(神逻辑？！)，因此可以放心的申请O(N)的额外空间进行Stable且O(NlogN)guarantee的归并排序；如果用户使用了原始类型，说明用户非常谨慎地考虑了内存使用问题，故Java退而求其次使用快速排序。但无论如何，快速排序和归并排序已经成为工业界的中流砥柱，分别在不同的情况下为计算机事业奉献自己的所有青春和力量，在此表示衷心的敬意！</p>

<h3 id="heap-sort">2.6 Heap Sort</h3>

<p>由前面的介绍知道，不同的数据结构实际上是有着不同的特性，这节首先以<strong>Priority Queue</strong>为起点，引出实现这一数据结构的的等效方法<strong>Binary Heap</strong>，接着思考如何利用这个数据结构实现排序的功能。下面先总结回顾一下目前已经介绍的数据结构的特性：</p>

<ul>
  <li><strong>Stack</strong>，remove the item most recently added；</li>
  <li><strong>Queue</strong>，remove the item least recently added；</li>
  <li><strong>Randmozied Queue</strong>，remove a random item。</li>
</ul>

<p>而在实际应用中，往往需要给不同的元素标记不同的优先级，然后根据优先级进行排序，每次选取出优先级最大(或最小)的元素，这就是<strong>Priority Queue</strong>。一般来说，Max Priority Queue需要支持以下的APIs:</p>

<ul>
  <li>void insert(Key v);</li>
  <li>key delMax();</li>
  <li>boolean isEmpth();</li>
</ul>

<p>首先上一张Roadmap：</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/Priority Queue.png" alt="Priority Queue" /></p>

<h4 id="elementary-implementation">2.6.1 Elementary Implementation</h4>

<p>前两种属于基本的实现方案，底层使用的是数组，不同的是一个保持数组有序(ordered)，另一个不需要保持数组有序(Unordered)。下面介绍无序的Java实现代码：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnorderedMaxPQ</span><span class="o">&lt;</span><span class="n">Key</span> <span class="kd">extends</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;&gt;{</span>  
    <span class="kd">private</span> <span class="n">Key</span><span class="o">[]</span> <span class="n">pq</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">N</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">UnorderedMaxPQ</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">){</span>
        <span class="n">pq</span> <span class="o">=</span> <span class="o">(</span><span class="n">Key</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Comparable</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmtpy</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">N</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Key</span> <span class="n">x</span><span class="o">){</span>
        <span class="n">pq</span><span class="o">[</span><span class="n">N</span><span class="o">++]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Key</span> <span class="nf">delMax</span><span class="o">(){</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">if</span><span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">max</span><span class="o">,</span><span class="n">i</span><span class="o">))</span> <span class="n">max</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">//放到数组末端</span>
        <span class="k">return</span> <span class="n">pq</span><span class="o">[--</span><span class="n">N</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>由上不难看出，在无序的版本中，insert操作非常迅速，O(1)即可，但是每次执行delMax都需要重新扫描数组，因此是O(N)的复杂度。</p>

<p>有序的版本不同的地方在于插入需要扫描一遍数组找到合适的插入的地方，然后还得不停地交换挪出空间给新插入的数组，因此在insert操作中复杂度为O(N)。由于数组已经有序，因此delMax操作非常迅速，直接删除即可。</p>

<p>哪么，我们思考，有没有更加高效的方法，使得三种操作的复杂度都是lgN呢？</p>

<h4 id="binary-heap-implementation">2.6.2 Binary Heap Implementation</h4>

<h5 id="binary-tree">2.6.2.1 Binary Tree</h5>
<p>在目前的介绍中我们发现，对于一个给定的数组，我们所有算法的扫描方式都是固定的，要么以<strong>下标递增</strong>的方式诸葛扫描，要么以<strong>下标递减</strong>的方式逐个扫描。我们不禁思考，有没有其他的方式组织和扫描一个数组呢？</p>

<p>请仔细观察下面的图片：</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/binary tree.png" alt="binary tree" /></p>

<p>观察一下每棵树的分支，发现没有，对于每一个根节点，都会生长出两个子节点出来，并且最高层的所有子节点都有叶节点。这就是计算机中大名鼎鼎的一种数据结构<strong>二叉树 Binary Tree</strong>的特例，<strong>满二叉树(Full Binary Tree)</strong>。</p>

<p>除此之外，还有另外一种二叉树，叫做<strong>完全二叉树(Complete Binary Tree)</strong>，与满二叉树不同，完全二叉树只要求除了最后一层之外的其它层是满的，最优一层的叶节点尽可能的往左靠拢，如下图所示：</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/Complete Binary Tree.png" alt="Complete Binary Tree" /></p>

<p>有人可能会问，这有什么用呀？别着急，如果我们以根节点从1开始逐层对完全二叉树进行编号，观察一下父节点(Parent)和子节点(Child)序号间的关系。发现没有：</p>

<ul>
  <li>子节点k的府机电一定是k/2；</li>
  <li>父节点k的两个子节点一定是2k和2K+1。</li>
</ul>

<p>不服？下面证明一下<strong>m-叉树</strong>的父节点和子节点编号的关系：</p>

<p>对于编号为k的节点，假设其处于第h层(根节点为第0层)，其m个子节点分别为C<sub>1</sub>，C<sub>2</sub>，…，C<sub>m</sub>。那么当层以前的所有节点个数为：</p>

<p style="text-align: center;">
S<sub>h-1</sub> = 1 + m<sup>1</sup> + m<sup>2</sup> + ... + m<sup>h-1</sup> 
</p>

<p>当层k节点前的节点个数为：</p>

<p style="text-align: center;">
k - S<sub>h-1</sub> - 1 
</p>

<p>那么k节点的第一个子节点编号为：</p>

<p style="text-align: center;">
C<sub>1</sub> = m * (k - S<sub>h-1</sub> - 1) + S<sub>h</sub> + 1 = mk - m + S<sub>h</sub> - mS<sub>h-1</sub> + 1
</p>

<p>有等比数列，又知：</p>

<p style="text-align: center;">
S<sub>h</sub> - m *S<sub>h-1</sub> = 1
</p>

<p>因此有：</p>
<p style="text-align: center;">
C<sub>1</sub> = mk - m + 2
</p>

<p>将m = 2带入即可得到子节点分别为2k和2k+1。</p>

<p>有了上面的观察和证明，我们就可以大胆的以树的形式把原来干巴巴的数组串起来，并且可以通过计算公式方便的<strong>在父节点和子节点穿梭自如</strong>。好了，下面进入正题，上面是Binary Heap？</p>

<h5 id="binary-heap">2.6.2.2 Binary Heap</h5>

<p>所谓<strong>二叉堆(Binary Heap)</strong>就是满足一下invariants的数据结构：</p>

<ul>
  <li>父节点与子节点保持固定的大小关系；</li>
  <li>大根堆中父节点大于子节点；</li>
  <li>小根堆中父节点小于子节点；</li>
  <li>两个子节点同样也是二叉堆。</li>
</ul>

<p>下面就四种不同的情形(scenarios)介绍一下为了维持上述的两个invarant而需要做的操作，注意下面讨论的是大根堆，小根堆同理。</p>

<ul>
  <li>S1：子节点的值大于父节点的值；</li>
</ul>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/S1.png" alt="Bottom up reheapify" /></p>

<p>如上图所示，子节点T比父节点P的值大，那么只需要将子节点与父节点交换即可，如果交换后依旧比新的父节点大，那么循环操作直到二叉堆的性质满足为止，Java代码非常简单，如下所示。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">swim</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">k</span><span class="o">)){</span>
        <span class="n">exchange</span><span class="o">(</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>S2:需要插入新的元素有了S1做铺垫，插入新元素的操作就比较简单了，如下图所示，可以首先将新元素添加到末尾，然后调用swim()操作即可，并且能保证做多只需要lgN+1次比较，如下图所示。</li>
</ul>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/S2.png" alt="BH insert" /></p>

<p>Java代码如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Key</span> <span class="n">x</span><span class="o">){</span>
    <span class="n">pq</span><span class="o">[++</span><span class="n">N</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
    <span class="n">swim</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>S3：父节点的值比子节点的值要小：</li>
</ul>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/S3.png" alt="Top down reheapify" /></p>

<p>如上图所示，这种情况下首先需要找出大的子节点，然后不停地与较大的子节点交换，知道满足大根堆的性质，注意这里有2lgN次的比较，Java代码如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">sink</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span> <span class="n">j</span><span class="o">++;</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">less</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">j</span><span class="o">);</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>S4：删除最大(最小)的元素，如下图所示，此时需要把T删除，首先交换T和最后一个元素H，然后对H调用sink函数即可，这里最多2lgN次的比较。</li>
</ul>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/S4.png" alt="remove maximum" /></p>

<p>Java代码如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre><span class="kd">private</span> <span class="kt">void</span> <span class="nf">delMax</span><span class="o">(){</span>
    <span class="k">while</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="o">){</span>
        <span class="n">Key</span> <span class="n">max</span> <span class="o">=</span> <span class="n">pq</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">exch</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">--);</span>
        <span class="n">sink</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">pq</span><span class="o">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>妥善处理好了以上的四种情形，那么我们的大根堆实际上就建立完成了，insert()和delMax()操作都实现了，并且都能在O(lgN)的复杂度内解决。除此以外，其实还有另外一种叫做<strong>斐波那契(Fibonacci Heap)</strong>能够进一步把insert的操作降低到O(1)，但是由于实现过于复杂没有得到广泛的实际应用。</p>

<p class="img_middle_mid"><img src="/assets/images/posts/2015-09-04/binary heap summary.png" alt="binary heap summary" /></p>

<h5 id="sorting">2.6.2.3 Sorting</h5>

<p>有了二叉堆作为底层的数据结构，堆排序就变得非常的方便，主要分为<strong>建堆</strong>和<strong>排序</strong>两个方面。</p>

<h5 id="build-heap">2.6.2.3.1 Build Heap</h5>

<p>建堆的过程非常直观，从倒数第二层开始，往上延伸，每次迭代调用sink函数妥当安置每一个节点，当前层以上的节点都是不可预见未知的节点，直到迭代了根节点为止，Java代码如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="n">k</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="o">;</span><span class="n">k</span><span class="o">--){</span>
    <span class="n">sink</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">N</span><span class="o">);</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>如下图所示，先处理E，再处理T-R-O-S</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-04/heap sorting.png" alt="Heap sorting" /></p>

<p>这是一种<strong>自底向上(Bottom up)</strong>的方法，非常的快速，只需要O(2N)的复杂度即可。</p>

<h5 id="sortdown">2.6.2.3.2 Sortdown</h5>

<p>这一步非常简单，就是反复删除对顶的元素，然后提升最后一个元素，调用sink(1)即可，完整的Java代码如下所示：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="n">Comparable</span><span class="o">[]</span> <span class="n">pq</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">--){</span>
        <span class="n">sink</span><span class="o">(</span><span class="n">pq</span><span class="o">,</span><span class="n">k</span><span class="o">,</span><span class="n">N</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">while</span><span class="o">(</span><span class="n">N</span><span class="o">&gt;</span><span class="mi">1</span><span class="o">){</span>
        <span class="n">exch</span><span class="o">(</span><span class="n">pq</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">N</span><span class="o">);</span>
        <span class="n">sinl</span><span class="o">(</span><span class="n">pg</span><span class="o">,</span><span class="mi">1</span><span class="o">,--</span><span class="n">N</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h5 id="mathmatics-analysisa">2.6.2.3.2 Mathmatics Analysis&lt;/a&gt;</h5>

<p>由上述的过程不难看出，堆排序在最坏情况的也能保证O(2NlgN)的复杂度，并且是inplace的！这是一个里程碑式的发现，回忆一下归并排序和快速排序，前者需要额外的O(N)存储空间，后者在最坏情况下退化到了Quadratic的复杂度。</p>

<p>因此，堆排序是一种同时优化了时间复杂度和空间父再度的<strong>次完美算法</strong>，之所以这么瘦是次完美，原因有以下三点：</p>

<ul>
  <li>Inner loop longer than quicksort’s；</li>
  <li>Make poor use of cache memory；</li>
  <li>Not Stable；</li>
</ul>

<p>对于第一点的理解，堆排序每次需要比较两次，既需要比较两个子节点的大小关系，也需要比较父节点和较大子节点的大小关系。</p>

<p>第二点在现代计算机应用中更为突出，就是不同于快排只是跟相邻的元素做比较，堆排序中需要子节点或者父节点比较，而这些节点，往往离得非常远，因此在效率上较低(数组取值时间复杂度不应该是O(1)？和下标大小有关？)。</p>

<p>第三点显而易见，在反复的交换中难免会打乱原有的相对顺序。</p>

<p>此外，若是从信息论的角度分析堆排序，在删除节点的步骤中，与之教皇的末尾节点的值必然不可能是新生成堆的最大值，也就是说，必然会往下sink。换句话说，新的对顶元素教皇或者不交货的概率是不相等的，也就不是最优。</p>

<h2 id="section-2">3 总结</h2>

<p>再次贴上全文一开始的一张图：</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-04/sorting algorithm.png" alt="Sorting algorithm" /></p>

<p>现在再看这张图，是不是有全新的感受了，我们看到比较接近<strong>holy sorting grail</strong>的算法就是归并排序，快速排序和堆排序。这也就是为什么他们三个常常用来相提并论的原因，各有所长，适用于不同的场合。</p>

<p>本文介绍了6种经典的排序方法:</p>

<ol>
  <li>基础排序: 选择排序和插入排序；</li>
  <li>希尔排序(插入排序基础上);</li>
  <li>合并排序和快速排序(分而治之);</li>
  <li>二叉堆排序(二叉树结构)。</li>
</ol>

<p>最后用MinPQ来实现8Puzzle自动求解的问题。</p>

<h2 id="section-3">4 参考资料</h2>
<ul>
  <li>
    <p><a href="http://algs4.cs.princeton.edu/home/">Algorithm</a>;</p>
  </li>
  <li>
    <p><a href="http://visualgo.net/">Visualize Algorithm</a>;</p>
  </li>
  <li>
    <p><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么样快</a>;</p>
  </li>
</ul>


            <div class="clearfix"></div>
        </div>


    
    <ul class="tag_box list-unstyled list-inline">
      <li><i class="fa fa-folder-open"></i></li>
      
      
      
        <li><a href="http://www.shunmian.me/categories.html#Algorithm-ref">
          Algorithm <span>(7)</span>
          
        </a></li>
      
      
    </ul>
    

    
    <ul class="list-inline">
      <li><i class="fa fa-tags"></i></li>
      
      
      
        <li>
          <a href="http://www.shunmian.me/tags.html#Sorting-ref">
          Sorting <span>(2)</span>
          
          </a>
        </li>
      
      
      
    </ul>
    

<hr />
<div >
    <section class="col-sm-7">
        <h4>Share Post</h4>
        <a class="btn btn-default btn-sm" href="http://twitter.com/share?text=Algorithm(三)： Sorting 排序 part II&via=Wanderl29817400" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fa fa-twitter fa-sm"></i>
        Twitter
        </a>

        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-sm"></i>
          Facebook
        </a>

        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-sm"></i>
          Google+
        </a>
    </section>

    <section class="col-sm-5">
        <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df" class="img-rounded" />
        <h4>Shunmian</h4>
        <p class="author-bio">节物风光不相待，桑田碧海须臾改，唯有美食和code不可辜负。</p>

    </section>

</div>
<div class="clearfix"></div>

<ul class="pager">
    
    <li class="previous"><a href="http://www.shunmian.me/algorithm/2015/09/03/Algorithm(%E4%B8%89)_Sorting-%E6%8E%92%E5%BA%8F-part-I.html" title= "">&larr; Previous</a></li>
    
    
    <li class="next">"<a href="http://www.shunmian.me/algorithm/2015/09/05/Algorithm(%E4%BA%94)_Searching-%E6%90%9C%E7%B4%A2.html" title= "Algorithm(五)： Searching 搜索">Next &rarr;</a></li>
    
</ul>

    <hr />
    
    <section class="comments" style="margin-top:15px;">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'shunmianjohnson'; // required: replace example with your forum shortname
        if(disqus_shortname){
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        }
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </section>
    
    </div>
    <div class="col-sm-1sidebar-2"></div>
    <div class="clearfix"></div>
</article>
<div class="clearfix"></div>


                <div class="footer">
                    <footer>
                        <hr />
                        <p> &copy: 2015 Shunmian with jekyll. Theme: <a href="https://github.com/dbtek/dbyll"dbyll</a> by dbtek.
                        </p>
                    </footer>
                </div>
            </div>
        </div>
    </div>


    <script src="/assets/js/jquery-2.2.0.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

    <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    <script type="text/javascript">

$youziku.load(".sidebar_bio", "bdcc72b8235345649b02c123dac5610b", "SiYuan-ExtraLight");


   $youziku.draw();
</script>

</body>

</html>

