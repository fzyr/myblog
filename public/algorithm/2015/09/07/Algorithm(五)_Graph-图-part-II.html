<!DOCTYPE html>
<html lang = "en">
<head>
    <!-- favicon -->
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/images/posts/favico/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/images/posts/favico/favico/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/images/posts/favico/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/images/posts/favico/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/images/posts/favico/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/images/posts/favico/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/images/posts/favico/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/images/posts/favico/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/posts/favico/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/images/posts/favico/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/posts/favico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/images/posts/favico/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/posts/favico/favicon-16x16.png">
    <link rel="manifest" href="/assets/images/posts/favico/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/images/posts/favico/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">   

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/font-awesome/css/font-awesome.min.css">
    <link href="/assets/css/styles.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/syntax.css">


    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,600' rel='stylesheet' type='text/css'>
<!--     <script type="text/javascript" src="http://api.youziku.com/webfont/FastJS/yzk_976E121ED7CC0870"></script> -->

    <title>SHUNMIAN</title>
</head>


<body>

    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-3 sidebar hidden-xs sidebar">
                
<!--sidebar.html-->
        <header class="sidebar_header " role="banner">
            <a href="http://www.shunmian.me/index.html">
                <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df?s=150" class="img-circle img-responsive center-block sidebar_logo sidebar_img" />
            </a>


            <h3 class="title text-center">
                <a href="http://www.shunmian.me/index.html">SHUNMIAN</a>
            </h3>

        </header>


        <hr class="hr_short"/>
        <div id = "bio" class="text-center sidebar_bio">
            

                <p>嗨，欢迎来到我的博客。<br/>
                我是Shunmian，一名iOS开发者。<br/>
                <hr class = "hr_short_low">
                正在学习Algorithm，Functional Programming，Machine Learning，Data Mining 和 Cloud Computation。 

                </p>

            
        </div>


        <hr class="hr_middle"/>
        <div id = "contact-list" class="text-center">
            <ul class="list-unstyled list-inline">
                <li>
                    
                    <a class="btn btn_info_outline" href="mailto:shunmian@gmail.com"><i class="fa fa-envelope fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-github fa-lg"></i></a>
                    
                </li>

                <li>
                    
                    <a class="btn btn_info_outline" href="https://github.com/shunmian"><i class="fa fa-twitter fa-lg"></i></a>
                    
                </li>

                <li>
                    <a class="btn btn_info_outline" href="http://www.shunmian.me/feed.xml"><i class="fa fa-rss fa-lg"></i></a>
                </li>
        </div>


        <hr class="hr_short"/>
        <div id = "contact-list" class="text-center">
            <ul class="unstyled-list list-inline">
                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/index.html"><i class="fa fa-home fa-md"></i> 主页</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/tags.html"><i class="fa fa-tags fa-md"></i> 标签</a>
                </li>

                <li>
                    <a class="btn btn_info_outline btn-sm" href="http://www.shunmian.me/categories.html"><i class="fa fa-list fa-md"></i> 分类</a>
                </li>
            </ul>
        </div>
        <div class="padding_bottom_500"></div>




<!--sidebar.html end-->

            </div>

            <div class="col-sm-9 col-sm-offset-3">
                

<div class="page-header col-sm-10 col-sm-offset-1">
    <h1 class="article_mainTitle">Algorithm(五)： Graph 图 Part II </h1>
    <span class="post_date">
        2015-09-07 •
    </span>
    <span class="post_category">
        Algorithm
    </span>
</div>

<article class="article">
    <div class="col-sm-10 col-sm-offset-1">
        <div class="article_mainBody">
            <p class="article_content_title">目录</p>

<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">1 图介绍</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">2 图算法</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">2.3 最小生成树</a>        <ul>
          <li><a href="#greedy-algorithm" id="markdown-toc-greedy-algorithm">2.3.1 Greedy Algorithm</a></li>
          <li><a href="#api" id="markdown-toc-api">2.3.2 API</a></li>
          <li><a href="#kruskal-mst-" id="markdown-toc-kruskal-mst-">2.3.3 Kruskal MST 算法</a></li>
          <li><a href="#prim-mst-" id="markdown-toc-prim-mst-">2.3.4 Prim MST 算法</a></li>
        </ul>
      </li>
      <li><a href="#section-3" id="markdown-toc-section-3">2.4 最短路径</a>        <ul>
          <li><a href="#dijkstra-" id="markdown-toc-dijkstra-">2.4.1 Dijkstra 算法</a></li>
          <li><a href="#acyclicsp-" id="markdown-toc-acyclicsp-">2.4.2 AcyclicSP 算法</a></li>
          <li><a href="#bellman-ford-" id="markdown-toc-bellman-ford-">2.4.3 Bellman-Ford 算法</a></li>
          <li><a href="#section-4" id="markdown-toc-section-4">2.4.4 小结</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#programming-assignment" id="markdown-toc-programming-assignment">3 Programming assignment</a>    <ul>
      <li><a href="#wordnet" id="markdown-toc-wordnet">3.1 WordNet</a></li>
      <li><a href="#seam-carving" id="markdown-toc-seam-carving">3.2 Seam Carving</a></li>
    </ul>
  </li>
  <li><a href="#section-5" id="markdown-toc-section-5">4 总结</a></li>
  <li><a href="#section-6" id="markdown-toc-section-6">5 参考资料</a></li>
</ul>

<hr class="hr-short-left" />

<h2 id="section">1 图介绍</h2>

<p>前文介绍了基本的无向图和有向图性质和一些算法应用，不难发现我们侧重的是<strong>拓扑连接</strong>，只是研究点和边的组合情况，并没有考虑边与边之间的不同。在本节中，我们将会把图问题进一步细化，引入<strong>边权值(edge weight)</strong>的概念。我们将会发现，一旦引入了边的权值，那么将会出现非常有意思的问题，比如：</p>

<ol>
  <li>最小生成树(Minimum Spanning Tree);</li>
  <li>最短路径(Shortest Path);</li>
  <li>最小割(Minimum Cut);</li>
  <li>最大流(Maximum Flow)。</li>
</ol>

<h2 id="section-1">2 图算法</h2>

<h3 id="section-2">2.3 最小生成树</h3>

<blockquote>
  <p><b>Minimum Spanning Tree</b>:a minimum <b>spanning</b>(includes all vertices) <b>tree</b>(connected acyclic) is a spanning tree whose weight (the sum of the weights of its edges) is no larger than the weight of any other spanning tree.</p>
</blockquote>

<p>Given any cut in an edge- weighted graph, the crossing edge of minimum weight is in the MST of the graph.</p>

<h4 id="greedy-algorithm">2.3.1 Greedy Algorithm</h4>

<blockquote>
<b>Cut</b>: A cut of a graph is a partition of its vertices into two nonempty disjoint sets. A crossing edge of a cut is an edge that connects a vertex in one set with a vertex in the other.<br />
<b>Cut property</b>: Given any cut in an edge- weighted graph, the crossing edge of minimum weight is in the MST of the graph.
</blockquote>

<h4 id="api">2.3.2 API</h4>

<p>首先定义Edge，包括连个顶点和一个weight。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Edge</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;{</span>
  
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">w</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">;</span>
   
   <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">(){</span>  <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>  <span class="o">}</span>       <span class="c1">//edge weight     </span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">either</span><span class="o">(){</span>  <span class="k">return</span> <span class="n">v</span><span class="o">;</span>  <span class="o">}</span>               <span class="c1">//one vertex</span>
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">other</span><span class="o">(</span><span class="kt">int</span> <span class="n">vertex</span><span class="o">){</span>                    <span class="c1">//the other vertex</span>
       <span class="k">if</span>      <span class="o">(</span><span class="n">vertex</span> <span class="o">==</span> <span class="n">v</span><span class="o">)</span> <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">vertex</span> <span class="o">==</span> <span class="n">w</span><span class="o">)</span> <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Inconsistent edge"</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Edge</span> <span class="n">that</span><span class="o">){</span>
      <span class="k">if</span>      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">that</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="k">return</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">else</span>                                    <span class="k">return</span>  <span class="mi">0</span><span class="o">;</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">(){</span>
     <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d-%d %.5f"</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>  
   <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>其次实现EdgeWeightedGraph，用邻接表实现，同一个edge出现两次引用，但是只有一个Edge object.</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/MST adjacent list.png" alt="adjacency-list" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EdgeWeightedGraph</span><span class="o">{</span>
  
   <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>             <span class="c1">//number of vertices</span>
   <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>                   <span class="c1">//number of edges</span>
   <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>         <span class="c1">//adjacency lists</span>
   
   <span class="kd">public</span> <span class="nf">EdgeWeightedGraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
         <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span> <span class="o">{</span>  <span class="k">return</span> <span class="n">V</span><span class="o">;</span>  <span class="o">}</span>       
   <span class="kd">public</span> <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span> <span class="o">{</span>  <span class="k">return</span> <span class="n">E</span><span class="o">;</span>  <span class="o">}</span>       
   
   <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">Edge</span> <span class="n">e</span><span class="o">){</span>         
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
      <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="n">adj</span><span class="o">[</span><span class="n">w</span><span class="o">].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="n">E</span><span class="o">++;</span>
   <span class="o">}</span>
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span> <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>  <span class="o">}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">(){</span>
     <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
       <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
          <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">])</span>
             <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
   <span class="o">}</span>

<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>最后是MST的API，其实现算法在2.3.3和2.3.4介绍。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MST</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">MST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">);</span>  <span class="c1">//constructor</span>
  <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">();</span>       <span class="c1">//all of the MST edges</span>
  <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span>           <span class="c1">//weight of MST</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="kruskal-mst-">2.3.3 Kruskal MST 算法</h4>

<blockquote>
<b>Kruskal MST Algorithm</b>: 
<ul>
<li>considerting edges in ascending order of weight.<br /></li>
<li>Add next edge to trees unless doing so would create acyclic(using union-find)</li>
</ul>
</blockquote>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/Kruskal.png" alt="Kruskal" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">KruskalMST</span><span class="o">{</span>
  
   <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">mst</span><span class="o">;</span>
   
   <span class="kd">public</span> <span class="nf">KruskalMST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">){</span>
      <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
      <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">edges</span><span class="o">())</span>
         <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="n">UF</span> <span class="n">uf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UF</span><span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
      
      <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">mst</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()-</span><span class="mi">1</span><span class="o">){</span>
         <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>                        <span class="c1">// Get min weight edge on pq</span>
         <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>          <span class="c1">// and its vertices.</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">uf</span><span class="o">.</span><span class="na">connected</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>            <span class="c1">// Ignore ineligible edges.</span>
         <span class="n">uf</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>                              <span class="c1">// Merge components.</span>
         <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>                              <span class="c1">// Add edge to mst.</span>
      <span class="o">}</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">(){</span> <span class="k">return</span> <span class="n">mst</span><span class="o">;</span>  <span class="o">}</span>
   
   <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">();</span>   
<span class="o">}</span> <span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="prim-mst-">2.3.4 Prim MST 算法</h4>

<blockquote>
  <p><b>Prim’s MST Algorithm</b>: Start with any vertex as a single vertex tree; then add V-1 edges to it, always taking next (coloring black) the minimum weight edge that connects a vertex on the tree to a vertex not yet on the tree (a crossing edge for the cut de ned by tree vertices). Two versions, lazy &amp; eager.</p>
</blockquote>

<p>Lazy Version.</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/prim lazy.png" alt="Prim lazy" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LazyPrimMST</span><span class="o">{</span>
  
   <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>                        <span class="c1">// MST vertices</span>
   <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">mst</span><span class="o">;</span>                         <span class="c1">// MST edges</span>
   <span class="kd">private</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>                          <span class="c1">// crossing (and ineligible) edges</span>

   <span class="kd">public</span> <span class="nf">LazyPrimMST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">){</span>
     <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinPQ</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
     <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
     <span class="n">mst</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;();</span>
     <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>                                   <span class="c1">// assumes G is connected</span>
     
     <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
       <span class="n">Edge</span> <span class="n">e</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">();</span>                        <span class="c1">// Get lowest-weight</span>
       <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">either</span><span class="o">(),</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>          <span class="c1">// edge from pq.</span>
       <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>        <span class="c1">// Skip if ineligible.</span>
          <span class="n">mst</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>                           <span class="c1">//Add edge to tree.</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">])</span> <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>              <span class="c1">//Add vertex to tree</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>              <span class="c1">// (either v or w).</span>
     <span class="o">}</span>
   <span class="o">}</span>


   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>  <span class="c1">// Mark v and add to pq all edges from v to unmarked vertices.</span>
      <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span>
         <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">)])</span> <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">(){</span><span class="k">return</span> <span class="n">mst</span><span class="o">;}</span>
   
   <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Eager Version.</p>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/prim eager.png" alt="Prim eager" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EagerPrimMST</span><span class="o">{</span>
 
  <span class="kd">private</span> <span class="n">Edge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>                            <span class="c1">// shortest edge from tree vertex</span>
  <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>                          <span class="c1">// distTo[w] = edgeTo[w].weight()</span>
  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>                         <span class="c1">// true if v on tree</span>
  <span class="kd">private</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>                    <span class="c1">// eligible crossing edges</span>

  <span class="kd">public</span> <span class="nf">EagerPrimMST</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">){</span>
    <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Edge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
    <span class="n">distTo</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">);</span>                              <span class="c1">// Initialize pq with 0, weight 0.</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
      <span class="n">visit</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">());</span>                        <span class="c1">// Add closest vertex to tree.</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(</span><span class="n">EdgeWeightedGraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>   <span class="c1">// Add v to tree; update data structures.</span>
    <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Edge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">)){</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">other</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>                      <span class="c1">//v-w is ineligible.</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]){</span>                  <span class="c1">// Edge e is new best connection from tree to w.</span>
        <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span> <span class="n">pq</span><span class="o">.</span><span class="na">changeKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
        <span class="k">else</span>                <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">();</span>
  
  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">();</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="section-3">2.4 最短路径</h3>

<blockquote>
  <p><b>Shortest Path Tree</b>: Given an edge-weighted digraph and a designated source vertex s, a shortest-paths tree for vertex s is a subgraph containing s and all the vertices reachable from s that forms a directed tree rooted at s such that every tree path is shortest path in the digraph.</p>
</blockquote>

<p>为了实现ShortestPathTree，我们必须有DirectedEdge， EdgeWeightedDigraph</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DirectedEdge</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span> <span class="c1">// edge tail</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">w</span><span class="o">;</span> <span class="c1">// edge head</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">;</span> <span class="c1">// edge weight</span>

  <span class="kd">public</span> <span class="nf">DirectedEdge</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="kt">double</span> <span class="n">weight</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">weight</span> <span class="o">=</span> <span class="n">weight</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">weight</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">weight</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">from</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">to</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d-&gt;%d %.2f"</span><span class="o">,</span> <span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">weight</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EdgeWeightedDigraph</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">V</span><span class="o">;</span>        <span class="c1">// number of vertices</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">E</span><span class="o">;</span>            <span class="c1">// number of edges</span>
  <span class="kd">private</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;[]</span> <span class="n">adj</span><span class="o">;</span>  <span class="c1">// adjacency lists</span>

  <span class="kd">public</span> <span class="nf">EdgeWeightedDigraph</span><span class="o">(</span><span class="kt">int</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">V</span> <span class="o">=</span> <span class="n">V</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">E</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="o">(</span><span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">[</span><span class="n">V</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
      <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">V</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">V</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">E</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">E</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addEdge</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">adj</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">from</span><span class="o">()].</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="n">E</span><span class="o">++;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">adj</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">edges</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">bag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bag</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">V</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">adj</span><span class="o">[</span><span class="n">v</span><span class="o">])</span>
        <span class="n">bag</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">bag</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SP</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">SP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">);</span>  <span class="c1">//constructor</span>
  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">);</span>        <span class="c1">//distance from s to v, infinity if no path</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>       <span class="c1">//path from s to v?</span>
  <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>    <span class="c1">//path from s to v, null if none</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="dijkstra-">2.4.1 Dijkstra 算法</h4>

<blockquote>
  <p><b>Dijkstra’s algorithm</b>: initialzing dis[s] to 0 and all other distTo[] entries to positive infinity, then we relax and add to the tree a non-tree vertex with the lowest distTo[] value, continuing until all vertices are on the tree or no non-tree vertex has a finiste distTo[] value.</p>
</blockquote>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/Dijkstra.png" alt="Dijkstra" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DijkstraSP</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">DijkstraSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
    <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IndexMinPQ</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;(</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">());</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
    <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
      <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">pq</span><span class="o">.</span><span class="na">delMin</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">DirectedEdge</span> <span class="n">e</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">weight</span><span class="o">();</span>
        <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span>
          <span class="n">pq</span><span class="o">.</span><span class="na">changeKey</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
        <span class="k">else</span>
          <span class="n">pq</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>
  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="acyclicsp-">2.4.2 AcyclicSP 算法</h4>
<blockquote>
  <p><b>Acyclic edge-weighted digraphs</b>: For many natural applications, edge-weeighted digraphs are know to have no directed cycles. We now consider an algorithm for finding shortest paths that is simpler and faster than Dijkstra’s algorithm for edge-weighted DAGs. Specifically, vertex relaxation, in combination with topological sorting, immediately presents a solution to the single-source shortes-paths probelm for edge-weighted DAGs. We initialize distTo[s] to 0 and all other distTo[] values to infinity, then relax the vertices , one by one, taking the vertices in topological order.</p>
</blockquote>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/AcyclicSP.png" alt="AcyclicSP" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AcyclicSP</span><span class="o">{</span>
  
   <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>
   <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>
   
   <span class="kd">public</span> <span class="nf">AcyclicSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
         <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
      <span class="n">Topological</span> <span class="n">top</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Topological</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">top</span><span class="o">.</span><span class="na">order</span><span class="o">())</span>
         <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
   <span class="o">}</span>
   
   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span>
   <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>         
   <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>      
   <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> 
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="bellman-ford-">2.4.3 Bellman-Ford 算法</h4>

<blockquote>
  <p><b>Bellman-Ford algorithm</b>: The queue-based implementation of the Bellman-Ford algorithm solves the single-source shortest-paths problem from a given source s(or finds a negative cycle reachable from s) for any edge-weighted digraph with E edges and V vertices, in time proportional to EV and extra space proportional to V, in the worst case.</p>
</blockquote>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/Bellman-ford.png" alt="Bellman-ford" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BellmanFordSP</span><span class="o">{</span>
  <span class="kd">private</span> <span class="kt">double</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>        <span class="c1">// length of path to v</span>
  <span class="kd">private</span> <span class="n">DirectedEdge</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>      <span class="c1">// last edge on path to v </span>
  <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">onQ</span><span class="o">;</span>          <span class="c1">// Is this vertex on the queue?</span>
  <span class="kd">private</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">;</span>     <span class="c1">// vertices being relaxed</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">cost</span><span class="o">;</span>           <span class="c1">// number of calls to relax()</span>
  <span class="kd">private</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="n">cycle</span><span class="o">;</span>   <span class="c1">// negative cycle in edgeTo[]?</span>
  
  <span class="kd">public</span> <span class="nf">BellmanFordSP</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">){</span>
    <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">onQ</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>
    <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="n">onQ</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hasNegativeCycle</span><span class="o">()){</span>
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
      <span class="n">onQ</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
      <span class="n">relax</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
     <span class="kd">private</span> <span class="kt">void</span> <span class="nf">relax</span><span class="o">(</span><span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span>
     <span class="kd">public</span> <span class="kt">double</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>          
     <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>      
     <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span>  
     <span class="kd">private</span> <span class="kt">void</span> <span class="nf">findNegativeCycle</span><span class="o">()</span>
     <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNegativeCycle</span><span class="o">()</span>
     <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">DirectedEdge</span><span class="o">&gt;</span> <span class="nf">negativeCycle</span><span class="o">()</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="section-4">2.4.4 小结</h4>

<p class="img_middle_lg"><img src="/assets/images/posts/2015-09-06/STSummary.png" alt="STSummary" /></p>

<h2 id="programming-assignment">3 Programming assignment</h2>

<h3 id="wordnet">3.1 WordNet</h3>

<p>SAP思路：要计算最短路径，因此bfs的distTo可以用到。只要将BreadthFirstPaths增加返回marked和distTo的函数，就可以知道和vertex S 连接的点及其距离。然后在int v和 int w的公共marked点里，求其最小的点。SAP就是一个Graph和Graph processing 解耦的典型例子，SAP建立在BreadFirstPaths基础上。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SAP</span> <span class="o">{</span>
  <span class="n">Digraph</span> <span class="n">G</span><span class="o">;</span>
  
  <span class="c1">// consructor takes a digraph (not necessarily a DAG)</span>
  <span class="kd">public</span> <span class="nf">SAP</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">;</span> 
  <span class="o">}</span>
  
  <span class="c1">// length of shortest ancestral path between v and w;-1 if no such path</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">length</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">shortPath</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
  <span class="o">}</span>
  
  <span class="c1">// a common ancestor of v and w that participates ina shortest ancestral path: -1 if no such path</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ancestor</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>
    <span class="k">return</span> <span class="nf">shortPath</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="n">w</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
  <span class="o">}</span>
  
  <span class="c1">// length of shortest ancestral path between any vertext in v and any vertex in w; -1 if no such path</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">length</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">w</span><span class="o">){</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">shortPath</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>

  <span class="o">}</span>
  
  <span class="c1">// a common ancestor that participates in shortest ancestral path: -1 if no such path</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">ancestor</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="n">v</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">w</span><span class="o">){</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">shortPath</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">shortPath</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">){</span>
    
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    
    <span class="n">UpgradedBFSDirectedPath</span> <span class="n">BFSV</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UpgradedBFSDirectedPath</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">markedV</span> <span class="o">=</span> <span class="n">BFSV</span><span class="o">.</span><span class="na">getMarked</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[]</span>   <span class="n">distV</span> <span class="o">=</span> <span class="n">BFSV</span><span class="o">.</span><span class="na">distTo</span><span class="o">;</span>
    
    <span class="n">UpgradedBFSDirectedPath</span> <span class="n">BFSW</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UpgradedBFSDirectedPath</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">markedW</span> <span class="o">=</span> <span class="n">BFSW</span><span class="o">.</span><span class="na">getMarked</span><span class="o">();</span>
    <span class="kt">int</span><span class="o">[]</span>   <span class="n">distW</span> <span class="o">=</span> <span class="n">BFSW</span><span class="o">.</span><span class="na">distTo</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="n">tempLength</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">markedV</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
      <span class="k">if</span><span class="o">((</span><span class="n">markedV</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;</span> <span class="n">markedW</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">distV</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span>  <span class="n">distW</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">&lt;</span> <span class="n">tempLength</span><span class="o">)){</span>
        <span class="n">tempLength</span> <span class="o">=</span> <span class="n">distV</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span>  <span class="n">distW</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">tempLength</span><span class="o">;</span>
        <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="k">if</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>

  
  <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">shortPath</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">w</span><span class="o">){</span>
    
    <span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    
    <span class="kt">int</span> <span class="n">minLength</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">i:</span> <span class="n">v</span><span class="o">){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">j:</span> <span class="n">w</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">shortPath</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">ancestor</span> <span class="o">=</span> <span class="n">shortPath</span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">!=-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="n">minLength</span><span class="o">){</span>
          <span class="n">minLength</span> <span class="o">=</span> <span class="n">length</span><span class="o">;</span>
          <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">minLength</span><span class="o">;</span>
          <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">;</span>
        <span class="o">}</span> 
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">StdOut</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"hello world0:"</span><span class="o">);</span>
    <span class="n">In</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">In</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="n">Digraph</span> <span class="n">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Digraph</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
    <span class="n">StdOut</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Digraph:"</span> <span class="o">+</span> <span class="n">G</span><span class="o">);</span>
    <span class="n">SAP</span> <span class="n">sap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SAP</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
    <span class="n">StdOut</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"hello world1:"</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">StdIn</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">StdIn</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
      <span class="n">StdOut</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"hello world2:"</span><span class="o">);</span>
      <span class="kt">int</span> <span class="n">length</span>   <span class="o">=</span> <span class="n">sap</span><span class="o">.</span><span class="na">length</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
      <span class="kt">int</span> <span class="n">ancestor</span> <span class="o">=</span> <span class="n">sap</span><span class="o">.</span><span class="na">ancestor</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
      <span class="n">StdOut</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"length = %d, ancestor = %d\n"</span><span class="o">,</span> <span class="n">length</span><span class="o">,</span> <span class="n">ancestor</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  
  <span class="cm">/*UpgradedBFSDirectedPath, with getMarked[]added-----------------------------*/</span>
  
  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">UpgradedBFSDirectedPath</span><span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INFINITY</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">marked</span><span class="o">;</span>  <span class="c1">// marked[v] = is there an s-&gt;v path?</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">edgeTo</span><span class="o">;</span>      <span class="c1">// edgeTo[v] = last edge on shortest s-&gt;v path</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">distTo</span><span class="o">;</span>      <span class="c1">// distTo[v] = length of shortest s-&gt;v path</span>

    <span class="kd">public</span> <span class="nf">UpgradedBFSDirectedPath</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
      <span class="n">bfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nf">UpgradedBFSDirectedPath</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">marked</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">distTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="n">edgeTo</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">()];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="na">V</span><span class="o">();</span> <span class="n">v</span><span class="o">++)</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
      <span class="n">bfs</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">sources</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// BFS from single source</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// BFS from multiple sources</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Digraph</span> <span class="n">G</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">:</span> <span class="n">sources</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">marked</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">distTo</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">:</span> <span class="n">G</span><span class="o">.</span><span class="na">adj</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="o">{</span>
          <span class="k">if</span> <span class="o">(!</span><span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">edgeTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
            <span class="n">distTo</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">marked</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">q</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
          <span class="o">}</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasPathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">marked</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">distTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">distTo</span><span class="o">[</span><span class="n">v</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="nf">getMarked</span><span class="o">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">marked</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">pathTo</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">hasPathTo</span><span class="o">(</span><span class="n">v</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
      <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">distTo</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">edgeTo</span><span class="o">[</span><span class="n">x</span><span class="o">])</span>
        <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
      <span class="n">path</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">path</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>WordNet思路: 这里有一些细节需要澄清，</p>

<ol>
  <li>首先，synset是一个vertex, hypernerm里存的是edges, 即synset-&gt;synset集合，因此synset和hypernerm可以构建图。</li>
  <li>WordNet API 需要返回synset里(vertex)的所有单词及判断单词是否在里面，由于需要快速查找，插入，因此用SET来保存单词Noun(iVar String noun &amp; iVar ArrayList id(每一个单词可以属于多个vertext)，实现Comparable)。</li>
  <li>idList数组保存vertex id 和 String的关系；</li>
  <li>判断WordNet是否为单root，hypernerm出现一项，标记其为true，最后数false的个数，有且只有一个为单root。</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordNet</span> <span class="o">{</span>
  
  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Noun</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Noun</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">noun</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">id</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>
    
    <span class="kd">public</span> <span class="nf">Noun</span><span class="o">(</span><span class="n">String</span> <span class="n">noun</span><span class="o">){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">noun</span> <span class="o">=</span> <span class="n">noun</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Noun</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">noun</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">noun</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">getId</span><span class="o">(){</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addId</span><span class="o">(</span><span class="n">Integer</span> <span class="n">x</span><span class="o">){</span>
      <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="c1">// constructor takes the name of the two input files</span>
  <span class="kd">private</span> <span class="n">SET</span><span class="o">&lt;</span><span class="n">Noun</span><span class="o">&gt;</span> <span class="n">nounSET</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">Digraph</span> <span class="n">G</span><span class="o">;</span>        <span class="c1">//store hypernym</span>
  <span class="kd">private</span> <span class="n">SAP</span> <span class="n">sap</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">idList</span><span class="o">;</span><span class="c1">//store synset</span>

  
  <span class="kd">public</span> <span class="nf">WordNet</span><span class="o">(</span><span class="n">String</span> <span class="n">synsets</span><span class="o">,</span> <span class="n">String</span> <span class="n">hypernyms</span><span class="o">){</span>
    <span class="n">In</span> <span class="n">inSynsets</span> <span class="o">=</span> <span class="k">new</span> <span class="n">In</span><span class="o">(</span><span class="n">synsets</span><span class="o">);</span>
    <span class="n">In</span> <span class="n">inHypernyms</span> <span class="o">=</span> <span class="k">new</span> <span class="n">In</span><span class="o">(</span><span class="n">hypernyms</span><span class="o">);</span>
    
    <span class="c1">//counting the total number of vertex</span>
    <span class="kt">int</span> <span class="n">maxVertex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">idList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">nounSET</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SET</span><span class="o">&lt;</span><span class="n">Noun</span><span class="o">&gt;();</span>
    
    <span class="c1">//start to read synsets.txt</span>
    <span class="n">String</span> <span class="n">line</span> <span class="o">=</span> <span class="n">inSynsets</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
      <span class="n">maxVertex</span><span class="o">++;</span>
      <span class="n">String</span><span class="o">[]</span> <span class="n">synsetLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
      <span class="c1">//String[0] is id</span>
      <span class="n">Integer</span> <span class="n">id</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">synsetLine</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
      <span class="c1">//String[1] is noun, split it and add to the set</span>
      <span class="n">String</span><span class="o">[]</span> <span class="n">nounSet</span> <span class="o">=</span> <span class="n">synsetLine</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
      <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">nounName:</span> <span class="n">nounSet</span><span class="o">){</span>
        <span class="n">Noun</span> <span class="n">noun</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Noun</span><span class="o">(</span><span class="n">nounName</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nounSET</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">noun</span><span class="o">)){</span>
          <span class="n">noun</span> <span class="o">=</span> <span class="n">nounSET</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="n">noun</span><span class="o">);</span>
          <span class="n">noun</span><span class="o">.</span><span class="na">addId</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
          <span class="n">nounSET</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">noun</span><span class="o">);</span>
          <span class="n">noun</span><span class="o">.</span><span class="na">addId</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>
      
      <span class="c1">// add it to the idList</span>
      <span class="n">idList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">synsetLine</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
      <span class="c1">//continue readind synsets</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">inSynsets</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="o">}</span>
      
    <span class="n">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Digraph</span><span class="o">(</span><span class="n">maxVertex</span><span class="o">);</span>
    <span class="c1">// the candidate root</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">isNotRoot</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">maxVertex</span><span class="o">];</span>
      
    <span class="c1">//start to read hypernyms.txt</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">inHypernyms</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
      <span class="n">String</span><span class="o">[]</span> <span class="n">hypernymsLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
      <span class="c1">//String[0] is id</span>
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">hypernymsLine</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
      <span class="n">isNotRoot</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="c1">//String[1] and others is its ancestor, constrcuting G</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hypernymsLine</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
        <span class="n">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">hypernymsLine</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
      <span class="o">}</span>
      <span class="n">line</span> <span class="o">=</span> <span class="n">inHypernyms</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
    <span class="o">}</span>
      
    <span class="c1">//test for root: no cycle</span>
    <span class="n">DirectedCycle</span> <span class="n">directedCycle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DirectedCycle</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">directedCycle</span><span class="o">.</span><span class="na">hasCycle</span><span class="o">()){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
      
    <span class="c1">//test for root: no more than on candidate root</span>
    <span class="kt">int</span> <span class="n">rootCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">boolean</span> <span class="nl">notRoot:</span> <span class="n">isNotRoot</span><span class="o">){</span>
      <span class="k">if</span><span class="o">(!</span><span class="n">notRoot</span><span class="o">){</span>
        <span class="n">rootCount</span><span class="o">++;</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">rootCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">sap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SAP</span><span class="o">(</span><span class="n">G</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="c1">// returns all WordNet nouns</span>
  
  <span class="kd">public</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="nf">nouns</span><span class="o">(){</span>
    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">nouns</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="n">Noun</span> <span class="nl">noun:</span> <span class="n">nounSET</span><span class="o">){</span>
      <span class="n">nouns</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">noun</span><span class="o">.</span><span class="na">noun</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">nouns</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="c1">// is the word a WordNet noun?</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isNoun</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">){</span>
    <span class="n">Noun</span> <span class="n">noun</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Noun</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">nounSET</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">noun</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="c1">// distance between nounA and nounB(defined below)</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">distance</span> <span class="o">(</span><span class="n">String</span> <span class="n">nounA</span><span class="o">,</span> <span class="n">String</span> <span class="n">nounB</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isNoun</span><span class="o">(</span><span class="n">nounA</span><span class="o">)){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isNoun</span><span class="o">(</span><span class="n">nounB</span><span class="o">)){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="n">Noun</span> <span class="n">nodeA</span> <span class="o">=</span> <span class="n">nounSET</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="k">new</span> <span class="n">Noun</span><span class="o">(</span><span class="n">nounA</span><span class="o">));</span>
    <span class="n">Noun</span> <span class="n">nodeB</span> <span class="o">=</span> <span class="n">nounSET</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="k">new</span> <span class="n">Noun</span><span class="o">(</span><span class="n">nounB</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">sap</span><span class="o">.</span><span class="na">length</span><span class="o">(</span><span class="n">nodeA</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">nodeB</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
  <span class="o">}</span>
  
  <span class="c1">// a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB</span>
  <span class="c1">// in a shortest ancestral path (defined below)</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">sap</span><span class="o">(</span><span class="n">String</span> <span class="n">nounA</span><span class="o">,</span> <span class="n">String</span> <span class="n">nounB</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isNoun</span><span class="o">(</span><span class="n">nounA</span><span class="o">)){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(!</span><span class="n">isNoun</span><span class="o">(</span><span class="n">nounB</span><span class="o">)){</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="n">Noun</span> <span class="n">nodeA</span> <span class="o">=</span> <span class="n">nounSET</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="k">new</span> <span class="n">Noun</span><span class="o">(</span><span class="n">nounA</span><span class="o">));</span>
    <span class="n">Noun</span> <span class="n">nodeB</span> <span class="o">=</span> <span class="n">nounSET</span><span class="o">.</span><span class="na">ceiling</span><span class="o">(</span><span class="k">new</span> <span class="n">Noun</span><span class="o">(</span><span class="n">nounB</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">idList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">sap</span><span class="o">.</span><span class="na">ancestor</span><span class="o">(</span><span class="n">nodeA</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">nodeB</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">synsets</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="n">String</span> <span class="n">hypernyms</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    
    <span class="n">WordNet</span> <span class="n">wordNet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WordNet</span><span class="o">(</span><span class="n">synsets</span><span class="o">,</span> <span class="n">hypernyms</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Outcast思路：求和。由于N*N矩阵对称，因此可以先填充再求和减少计算次数。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Outcast</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">WordNet</span> <span class="n">wordNet</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="nf">Outcast</span><span class="o">(</span><span class="n">WordNet</span> <span class="n">wordNet</span><span class="o">){</span>
    <span class="k">this</span><span class="o">.</span><span class="na">wordNet</span> <span class="o">=</span> <span class="n">wordNet</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="n">String</span> <span class="nf">outcast</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">nouns</span><span class="o">){</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nouns</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>  
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nouns</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>  
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nouns</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>  
                <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">wordNet</span><span class="o">.</span><span class="na">distance</span><span class="o">(</span><span class="n">nouns</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nouns</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
                <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dist</span><span class="o">;</span>  
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">){</span>  
                    <span class="n">distance</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">dist</span><span class="o">;</span>  
                <span class="o">}</span>  
            <span class="o">}</span>  
        <span class="o">}</span>  
        <span class="kt">int</span> <span class="n">maxDistance</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">maxIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">distance</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>  
            <span class="k">if</span> <span class="o">(</span><span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">maxDistance</span><span class="o">){</span>  
                <span class="n">maxDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>  
                <span class="n">maxIndex</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>  
            <span class="o">}</span>  
        <span class="o">}</span>  
        <span class="k">return</span> <span class="n">nouns</span><span class="o">[</span><span class="n">maxIndex</span><span class="o">];</span>  
    <span class="o">}</span>  

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">WordNet</span> <span class="n">wordnet</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WordNet</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
    <span class="n">Outcast</span> <span class="n">outcast</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Outcast</span><span class="o">(</span><span class="n">wordnet</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">t</span><span class="o">++){</span>
      <span class="n">In</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">In</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">t</span><span class="o">]);</span>
      <span class="n">String</span><span class="o">[]</span> <span class="n">nouns</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readAllStrings</span><span class="o">();</span>
      <span class="n">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">t</span><span class="o">]</span> <span class="o">+</span> <span class="s">":"</span> <span class="o">+</span> <span class="n">outcast</span><span class="o">.</span><span class="na">outcast</span><span class="o">(</span><span class="n">nouns</span><span class="o">));</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="seam-carving">3.2 Seam Carving</h3>

<p>思路：</p>

<ol>
  <li>用一个virtual top vertice 和 vritual bottom vertice,然后求它们的最短路径。</li>
  <li>Vertice(像素), DirectedEdge是每一个像素和它下面,下左,下右。</li>
  <li>建立一个EdgeWeightedDigraph，然后用AcyclicSP,选取最短路径。</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.awt.Color</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">edu.princeton.cs.algs4.AcyclicSP</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">edu.princeton.cs.algs4.DirectedEdge</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">edu.princeton.cs.algs4.EdgeWeightedDigraph</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">edu.princeton.cs.algs4.Picture</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SeamCarver</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">Picture</span> <span class="n">picture</span><span class="o">;</span>
  
  <span class="kd">private</span> <span class="kt">double</span><span class="o">[][]</span> <span class="n">energyMatrix</span><span class="o">;</span>          <span class="c1">//energyMatrix</span>
  <span class="kd">private</span> <span class="n">EdgeWeightedDigraph</span> <span class="n">G</span><span class="o">;</span>            <span class="c1">//G</span>
  <span class="kd">private</span> <span class="n">Color</span><span class="o">[][]</span> <span class="n">colors</span><span class="o">;</span>             <span class="c1">// the basic information</span>
  
  <span class="kd">public</span> <span class="nf">SeamCarver</span><span class="o">(</span><span class="n">Picture</span> <span class="n">picture</span><span class="o">){</span>         <span class="c1">// create a seam carver object based on the given picture</span>
    <span class="k">this</span><span class="o">.</span><span class="na">picture</span> <span class="o">=</span> <span class="n">picture</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Color</span><span class="o">[</span><span class="n">picture</span><span class="o">.</span><span class="na">width</span><span class="o">()][</span><span class="n">picture</span><span class="o">.</span><span class="na">height</span><span class="o">()];</span>   <span class="c1">// make colors ready before calling other function</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">picture</span><span class="o">.</span><span class="na">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">picture</span><span class="o">.</span><span class="na">height</span><span class="o">();</span> <span class="n">row</span><span class="o">++){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">picture</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">row</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">initialize</span><span class="o">(){</span>            
    <span class="k">this</span><span class="o">.</span><span class="na">energyMatrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()][</span><span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()];</span>  <span class="c1">//construct energyMatrix from colors</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">();</span> <span class="n">row</span><span class="o">++){</span>
        <span class="n">energyMatrix</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">energy</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">row</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="k">this</span><span class="o">.</span><span class="na">G</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EdgeWeightedDigraph</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()*</span><span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()+</span><span class="mi">2</span><span class="o">);</span>   <span class="c1">//construct energyMatrix from colors</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>           <span class="c1">//add top </span>
      <span class="k">this</span><span class="o">.</span><span class="na">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">colRowToV</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">col</span><span class="o">),</span> <span class="mi">0</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>            <span class="c1">//add bottom</span>
      <span class="k">this</span><span class="o">.</span><span class="na">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">colRowToV</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()-</span><span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">),</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()*</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()+</span><span class="mi">1</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">energyMatrix</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()-</span><span class="mi">1</span><span class="o">]));</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">();</span> <span class="n">row</span><span class="o">++){</span>           <span class="c1">//add all other edges</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>
        <span class="kt">int</span> <span class="n">vertice</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colRowToV</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span><span class="k">this</span><span class="o">.</span><span class="na">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">(</span><span class="n">vertice</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">colRowToV</span><span class="o">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">),</span> <span class="k">this</span><span class="o">.</span><span class="na">energyMatrix</span><span class="o">[</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">]));</span>
        <span class="k">this</span><span class="o">.</span><span class="na">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">(</span><span class="n">vertice</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">colRowToV</span><span class="o">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">),</span><span class="k">this</span><span class="o">.</span><span class="na">energyMatrix</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">]));</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="o">()-</span><span class="mi">1</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">G</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="k">new</span> <span class="n">DirectedEdge</span><span class="o">(</span><span class="n">vertice</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">colRowToV</span><span class="o">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">),</span><span class="k">this</span><span class="o">.</span><span class="na">energyMatrix</span><span class="o">[</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">]));</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="kt">int</span> <span class="nf">colRowToV</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">){</span>    <span class="c1">//convert x,y index into vertices</span>
    <span class="k">return</span> <span class="n">row</span> <span class="o">*</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()</span> <span class="o">+</span> <span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="n">Picture</span> <span class="nf">picture</span><span class="o">(){</span>           <span class="c1">// current picture</span>
    
    <span class="n">Picture</span> <span class="n">newPicture</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Picture</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">(),</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">());</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">newPicture</span><span class="o">.</span><span class="na">height</span><span class="o">();</span> <span class="n">row</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">newPicture</span><span class="o">.</span><span class="na">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>
        <span class="n">newPicture</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">picture</span> <span class="o">=</span> <span class="n">newPicture</span><span class="o">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">picture</span><span class="o">;</span>
  <span class="o">}</span>           
  
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">width</span><span class="o">(){</span>               <span class="c1">// width of current picture</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(){</span>              <span class="c1">// height of current picture</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kt">double</span> <span class="nf">energy</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>       <span class="c1">// energy of pixel at column x and row y</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">();</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()-</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mf">1000.00</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">energy</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">xEnergy</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span> <span class="o">+</span> <span class="n">yEnergy</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">energy</span><span class="o">;</span>
  <span class="o">}</span>
  
  
  <span class="kd">private</span> <span class="kt">double</span> <span class="nf">xEnergy</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
    
    <span class="n">Color</span> <span class="n">leftColor</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>
    <span class="n">Color</span> <span class="n">rightColor</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>
    <span class="kt">double</span> <span class="n">Rx</span> <span class="o">=</span> <span class="n">leftColor</span><span class="o">.</span><span class="na">getRed</span><span class="o">()-</span><span class="n">rightColor</span><span class="o">.</span><span class="na">getRed</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">Gx</span> <span class="o">=</span> <span class="n">leftColor</span><span class="o">.</span><span class="na">getGreen</span><span class="o">()-</span><span class="n">rightColor</span><span class="o">.</span><span class="na">getGreen</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">Bx</span> <span class="o">=</span> <span class="n">leftColor</span><span class="o">.</span><span class="na">getBlue</span><span class="o">()-</span><span class="n">rightColor</span><span class="o">.</span><span class="na">getBlue</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">xEnergySquare</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">Rx</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">Gx</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">Bx</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">xEnergySquare</span><span class="o">;</span>
  <span class="o">}</span>

  
  <span class="kd">private</span> <span class="kt">double</span> <span class="nf">yEnergy</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">){</span>
  
    <span class="n">Color</span> <span class="n">topColor</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="n">Color</span> <span class="n">bottomColor</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="kt">double</span> <span class="n">Ry</span> <span class="o">=</span> <span class="n">topColor</span><span class="o">.</span><span class="na">getRed</span><span class="o">()-</span><span class="n">bottomColor</span><span class="o">.</span><span class="na">getRed</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">Gy</span> <span class="o">=</span> <span class="n">topColor</span><span class="o">.</span><span class="na">getGreen</span><span class="o">()-</span><span class="n">bottomColor</span><span class="o">.</span><span class="na">getGreen</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">By</span> <span class="o">=</span> <span class="n">topColor</span><span class="o">.</span><span class="na">getBlue</span><span class="o">()-</span><span class="n">bottomColor</span><span class="o">.</span><span class="na">getBlue</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">yEnergySquare</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">Ry</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">Gy</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">By</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">yEnergySquare</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findHorizontalSeam</span><span class="o">(){</span>        <span class="c1">// sequence of indices for horizontal seam</span>
    <span class="n">SeamCarver</span> <span class="n">horizontalSC</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SeamCarver</span><span class="o">(</span><span class="n">transpose</span><span class="o">());</span>
    <span class="k">return</span> <span class="n">horizontalSC</span><span class="o">.</span><span class="na">findVerticalSeam</span><span class="o">();</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="n">Picture</span> <span class="nf">transpose</span><span class="o">(){</span>
    <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">();</span>
    
    <span class="n">Picture</span> <span class="n">newPicture</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Picture</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">width</span><span class="o">;</span> <span class="n">col</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">height</span><span class="o">;</span> <span class="n">row</span><span class="o">++){</span>
        <span class="n">Color</span> <span class="n">color</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
        <span class="n">newPicture</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">col</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">color</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">newPicture</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">findVerticalSeam</span><span class="o">(){</span>        <span class="c1">// sequences of indices for vertical seam</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">solutionSteps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">height</span><span class="o">()];</span>
    <span class="n">AcyclicSP</span> <span class="n">aSP</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AcyclicSP</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">G</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="n">DirectedEdge</span> <span class="nl">e:</span> <span class="n">aSP</span><span class="o">.</span><span class="na">pathTo</span><span class="o">(</span><span class="n">width</span><span class="o">()*</span><span class="n">height</span><span class="o">()+</span><span class="mi">1</span><span class="o">)){</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">()</span> <span class="o">==</span> <span class="n">width</span><span class="o">()*</span><span class="n">height</span><span class="o">()+</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">to</span><span class="o">()</span> <span class="o">%</span> <span class="n">width</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
      <span class="n">solutionSteps</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>
      <span class="n">i</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">solutionSteps</span><span class="o">;</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeHorizontalSeam</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">seam</span><span class="o">){</span>   <span class="c1">// remove horizontal seam from current picture</span>
  
    <span class="n">Color</span><span class="o">[][]</span> <span class="n">newColors</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Color</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()][</span><span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()-</span><span class="mi">1</span><span class="o">];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span><span class="o">&lt;</span> <span class="nf">width</span><span class="o">();</span> <span class="n">col</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">row</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">seam</span><span class="o">[</span><span class="n">col</span><span class="o">])</span> <span class="n">newColors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
        <span class="k">else</span><span class="o">{</span>
          <span class="n">newColors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">colors</span> <span class="o">=</span> <span class="n">newColors</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeVerticalSeam</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">seam</span><span class="o">){</span>   <span class="c1">// remove vertical seam from current picture</span>
    
    <span class="n">Color</span><span class="o">[][]</span> <span class="n">newColors</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Color</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()-</span><span class="mi">1</span><span class="o">][</span><span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">()];</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">height</span><span class="o">();</span> <span class="n">row</span><span class="o">++){</span>
      <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">width</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span> <span class="n">col</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">seam</span><span class="o">[</span><span class="n">row</span><span class="o">])</span> <span class="n">newColors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
        <span class="k">else</span><span class="o">{</span>
          <span class="n">newColors</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">colors</span><span class="o">[</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">colors</span> <span class="o">=</span> <span class="n">newColors</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="section-5">4 总结</h2>

<p>本文介绍了6种经典的搜索方法来实现Symbol Table:</p>

<ol>
  <li>顺序搜索(无序链表)实现</li>
  <li>二分法搜索(有序数组)实现</li>
  <li>二叉搜索树实现</li>
  <li>平衡二叉搜索树(红黑树)实现</li>
  <li>哈希表实现(单独链表法 &amp; 线性探查法)</li>
</ol>

<p>其中哈希表的搜索在最坏的情况下是~lg(N)，在最好的情况下是~O(1)，是5个算法中最优的算法。但是需要注意hashCode冲突的情况。</p>

<h2 id="section-6">5 参考资料</h2>
<ul>
  <li>
    <p><a href="http://algs4.cs.princeton.edu/home/">Algorithm</a>;</p>
  </li>
  <li>
    <p><a href="http://visualgo.net/">Visualize Algorithm</a>;</p>
  </li>
</ul>


            <div class="clearfix"></div>
        </div>


    
    <ul class="tag_box list-unstyled list-inline">
      <li><i class="fa fa-folder-open"></i></li>
      
      
      
        <li><a href="http://www.shunmian.me/categories.html#Algorithm-ref">
          Algorithm <span>(7)</span>
          
        </a></li>
      
      
    </ul>
    

    
    <ul class="list-inline">
      <li><i class="fa fa-tags"></i></li>
      
      
      
        <li>
          <a href="http://www.shunmian.me/tags.html#Graph-ref">
          Graph <span>(2)</span>
          
          </a>
        </li>
      
      
      
    </ul>
    

<hr />
<div >
    <section class="col-sm-7">
        <h4>Share Post</h4>
        <a class="btn btn-default btn-sm" href="http://twitter.com/share?text=Algorithm(五)： Graph 图 Part II&via=Wanderl29817400" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fa fa-twitter fa-sm"></i>
        Twitter
        </a>

        <a class="btn btn-default btn-sm facebook" href="https://www.facebook.com/sharer/sharer.php"
           onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
          <i class="fa fa-facebook fa-sm"></i>
          Facebook
        </a>

        <a class="btn btn-default btn-sm gplus"
           onclick="window.open('https://plus.google.com/share?url='+window.location.href, 'google-plus-share', 'width=490,height=530');return false;">
          <i class="fa fa-google-plus fa-sm"></i>
          Google+
        </a>
    </section>

    <section class="col-sm-5">
        <img src = "https://www.gravatar.com/avatar/02eefecba7f0b21939d12a37f94bf5df" class="img-rounded" />
        <h4>Shunmian</h4>
        <p class="author-bio">节物风光不相待，桑田碧海须臾改，唯有美食和code不可辜负。</p>

    </section>

</div>
<div class="clearfix"></div>

<ul class="pager">
    
    <li class="previous"><a href="http://www.shunmian.me/algorithm/2015/09/06/Algorithm(%E4%BA%94)_Graph-%E5%9B%BE-part-I.html" title= "">&larr; Previous</a></li>
    
    
    <li class="next">"<a href="http://www.shunmian.me/functional%20programming/2015/10/01/Functional-Programming-in-Scala(%E4%B8%80)_%CE%BB-%E6%BC%94%E7%AE%97-Part-I-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC.html" title= "FP in Scala(一)：λ-演算 Part I：表达式，函数和赋值">Next &rarr;</a></li>
    
</ul>

    <hr />
    
    <section class="comments" style="margin-top:15px;">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'shunmianjohnson'; // required: replace example with your forum shortname
        if(disqus_shortname){
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        }
      </script>
      <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </section>
    
    </div>
    <div class="col-sm-1sidebar-2"></div>
    <div class="clearfix"></div>
</article>
<div class="clearfix"></div>


                <div class="footer">
                    <footer>
                        <hr />
                        <p> &copy: 2015 Shunmian with jekyll. Theme: <a href="https://github.com/dbtek/dbyll"dbyll</a> by dbtek.
                        </p>
                    </footer>
                </div>
            </div>
        </div>
    </div>


    <script src="/assets/js/jquery-2.2.0.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script src="/assets/js/script.js"></script>
    <script type="text/javascript">

$youziku.load(".sidebar_bio", "bdcc72b8235345649b02c123dac5610b", "SiYuan-ExtraLight");


   $youziku.draw();
</script>

</body>

</html>

