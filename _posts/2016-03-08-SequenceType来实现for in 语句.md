---
layout: post
title: SequenceType实现"for...in"语句
categories: [Swift]
tags: [protocol]
number: [4.8.1]
fullview: false
shortinfo: 在swift中，我们可以对Array用"for...in"快捷语句进行枚举，这比用下标循环要方便很多。那么，我们可以给我们自己的类也实现"for...in"语法吗。 答案是肯定的，我们要用到Swift内建的protocol SequenceType。借着这篇文章，我们对swift强大的内建protocol来看看其冰山一角。
---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## 1. SequenceType 介绍 ##
工欲善其事必先利其器。对于面向对象编程来说，面向接口编程优于面向继承编程(Swift和Objective-C一样都是单继承)。接口在Swift就是protocol. Swift从一开始就是一门protocol oriented programming language, 其强大的protocol功能(包括泛型, extension的默认实现，associated type等)给其其他语言无法比拟的灵活性和全面性。Swift内建了70多个公共接口，这些每个接口就像梯子的每个台阶一样，从各个角度来定义某种接口需要的属性和方法，同时在一个又一个的完美的台阶上，搭建出了例如Array, NSDictionary等功能丰富的内置类。理解Swift内置接口对于实现我们自己的类起着事半功倍的效果---我们要解决的问题，swift工程师可能已经有成熟的解决方案了。让我们借着用SequenceType这个protocol实现"for...in"枚举功能，来看看swift的内置协议。

我们再来看看Sequence的定义

>A sequence of events or things is a number of events or things that come one after another in a particular order

即Sequence是指有先后顺序的一列东西，SequenceType我们可以翻译成序列类。
我们再来看看SequenceType 在Swift 文档中的定义：






{% highlight objective-c linenos %}
SequenceType protocol：A Type that can be iterated with a for...in loop。

typealias Generator: GeneratorType // a type that provides the sequence's iteration interface and encapsutlates its iteration state.

func generate() ->Self.Generator //required, return a generator over the elements of this sequence.

{% endhighlight %}


文档中说的比较清楚，SequenceType只有一个功能，那就是可以用for..in 循环进行迭代。
SquenceType有一个associate type: Generator(本身继承自GeneratorType 协议), 作为迭代的接口(迭代器，或者产生器)；它还有一个required的方法generate()，返回值是Self.Generator。

我们再来看看GeneratorType在Swift文档中的定义

{% highlight objective-c linenos %}
GeneratorType protocol: Encapsulates iteration state and interface for interation over a sequence.

typealias Element //the type of element generated by self

mutating func next() ->Self.Element //required, advance to the next element and return it, or nil if no next element exists.

{% endhighlight %}

GeneratorType有一个associate type Element, 是self 产生的type； 还有一个方法next(), 返回Element?。
下面我们举一个简单的例子来实现我们一个BookList的for...in 功能。




## 2. for...in 例子##
问题： 我们有一个自定义的类BookList，里面放着Book类，实现BookList的for...in枚举方法，可以正向遍历或者反向遍历。

### 2.1 BookList for...in正向遍历###

{% highlight swift linenos %}
//  这是Book类，作为BookList的元素
class Book {
    var name = ""
    var price = 0.0
    init(name:String, price: Double){
        self.name = name
        self.price = price
    }
}

/*  BookListGenerator类，初始化时用一个[Book]?可选数组。
    关联类别名是Book； 方法next()返回Book或者nil。*/
class BookListGenerator: GeneratorType{
    var bookList:[Book]?
    var currentIndex:Int = 0
    
    init(bookList:[Book]?){
        self.bookList = bookList
    }
    
    typealias Element = Book
    func next() -> Element? {
        guard let list = self.bookList else{return nil}
        
        if self.currentIndex < list.count{
            let element = list[self.currentIndex]
            currentIndex++
            return element
        }else{
            return nil
        }

    }
}

/*  BookList类，初始化为一[Book]空数组。
    关联类别名是BookListGenerator, 方法generate返回BookListGenerator。*/
class BookList:SequenceType {
    var bookList:[Book]?
    
    init(){
        self.bookList = [Book]()
    }
    
    func addBook(book: Book){
        self.bookList?.append(book)
    }
    
    func removeBookAtIndex(index: Int){
        self.bookList?.removeAtIndex(index)
    }
    
    typealias Generator = BookListGenerator
    func generate() -> Generator {
        return BookListGenerator(bookList: self.bookList)
    }
}

{% endhighlight %}

我们来试一下for...in枚举方法

{% highlight swift linenos %}
var book1 = Book(name: "c", price: 12.0)
var book2 = Book(name: "iOS", price: 18.0)
var book3 = Book(name: "Swift", price: 24.0)

var customizedBookList = BookList()
customizedBookList.addBook(book1)
customizedBookList.addBook(book2)
customizedBookList.addBook(book3)


for book in customizedBookList{
    print("Book-------name: \(book.name); price \(book.price)")
}
/*  输出为：
    Book-------name: c; price 12.0
    Book-------name: iOS; price 18.0
    Book-------name: Swift; price 24.0
*/
{% endhighlight %}

### 2.2 BookList for...in反向遍历###
实现了正向遍历，反向遍历就很简单了，代码如下

{% highlight swift linenos %}
class BookListGenerator: GeneratorType{
...
    typealias Element = Book
    func next() -> Element? {
        guard let list = self.bookList else{return nil}
        
        if self.currentIndex < list.count{
            let element = list[list.count-self.currentIndex-1]
            currentIndex++
            return element
        }else{
            return nil
        }
    }
...
}
{% endhighlight %}
同样的例子，输出如下:

{% highlight swift linenos %}
for book in customizedBookList{
    print("Book-------name: \(book.name); price \(book.price)")
}
/*  输出为：
    Book-------name: Swift; price 24.0
    Book-------name: iOS; price 18.0
    Book-------name: c; price 12.0
*/
{% endhighlight %}
## 3 SequenceType: map, filter, reduce
SequenceType 默认实现了很多高阶函数，例如map, filter, reduce等，因此实现SequenceType的类就可以用这些函数，举例如下:



{% highlight swift linenos %}
//map 函数计算每本书的进价，返回数组
var boughtPrice = customizedBookList.map{return $0.price * 0.8}
print(boughtPrice)
/*  输出为：
    [9.6, 14.4, 19.2]
*/

//filter函数返回价格<20的Book数组
var lowPriceBooks = customizedBookList.filter{$0.price < 20}
for book in lowPriceBooks{
    print("Book-------name: \(book.name); price \(book.price)")
}
/*  输出为：
    Book-------name: c; price 12.0
    Book-------name: iOS; price 18.0
*/

/*reduce函数返回价格最高的Book,这里初始值应该是customizedBookList[0],
由于其还没有实现Indexable接口，因此不能用下标取其元素，我们用book1替代*/
var highestPriceBook: Book = customizedBookList.reduce(book1){
    $0.price > $1.price ? $0: $1
}
print("Highest Price Book-------name: \(highestPriceBook.name); price \(highestPriceBook.price)")
/*  输出为：
    Highest Price Book-------name: Swift; price 24.0
*/

{% endhighlight %}



## 4 总结 ##
用正向和方向遍历的例子想要得出的结论是for...in的枚举顺序我们可以通过SequenceType来定制。同时实现了SequenceType接口的类可以享用其默认实现了的高阶函数, 如map，filter，reduce等。
