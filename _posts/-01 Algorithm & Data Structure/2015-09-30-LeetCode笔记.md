---
layout: post
title: A1：LeetCode笔记
categories: [-01 Algorithm]
tags: [Graph]
number: [-2.2.4]
fullview: false
shortinfo: LeetCode笔记。
---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## Chapter 1 基础 ##

### (2) Add Two Numbers ###

**Add Two Numbers**: You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself. 

<blockquote>
<strong>For example</strong><br> 
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4),<br>
Output: 7 -> 0 -> 8, 
</blockquote>

分析：本题的本质是**Chapter 1 基础**里的**LinkedList**的运用。分两步：第1步是扫描完l1和l2，需要考虑l1和l2长度不相等的情况；第2步是第1步结束后，看看有没有进位，如果有，再增加1个ListNode(1)。tricky的地方在于第1步while里如何协调root的初始化和n的新建，解决方式之一是root的初始化在while前面，while里面n正常新建，但是最后返回的是``root.next``而不是``root``。有人将step2合并到step1里，我觉得分开逻辑更清楚。

{% highlight python linenos %}
# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        root = ListNode(0)
        n = root
        carry = 0
        while l1 or l2:                 # step 1: until all the node l1 and l2 are scanning over
            n.next = ListNode(0)
            n = n.next

            v1, v2 = 0, 0
            if l1:
                v1, l1 = l1.val, l1,next
            if v2:
                v2, l2 = l2.val, l2.next

            carry, n.val = divmod(v1+v2+carry,10)

        if carry:                       # step2: after step, if exists carry, add one more node
            n.next = ListNode(1)

        return root.next
{% endhighlight %}

### (7) Reverse Integer ###

**Reverse Integer**:Reverse digits of an integer.

<blockquote>
<strong>Example1</strong><br> 
x = 123, return 321<br>
<br>
<strong>Example2</strong><br> 
x = -123, return -321,<br>
</blockquote>

Note:
The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.

分析：本题本质是对整数的操作。Python里对溢出判断需要仔细考虑。

{% highlight python linenos %}
class Solution(object):
    def reverse(self, x):
        """
        :type x: int
        :rtype: int
        """
        tempX = abs(x)
        ans = 0
        while(tempX > 0):
            digit = tempX % 10
            tempX = tempX // 10
            ans = ans*10 + digit

        if x < 0:
            ans = -ans
        if ans > 0x7FFFFFFF or ans < -0x80000000:
            return 0
        return ans
class Solution(object):

{% endhighlight %}


### (11) Container With Most Water ###

**Container With Most Water**:Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

<blockquote>
<strong>Example1</strong><br> 
height = [1,1], return 1<br>
<br>
<strong>Example2</strong><br> 
height = [1,2,4,3], return 2<br>
</blockquote>

分析：本题本质是双指针操作。如果用暴力算法，两两比较，需要$O(N^2)$时间复杂度。如何降低呢。通过分析我们知道$area = \Delta x× min(y_1,y_2)$，因此我们可以用两个指针l,r初始分别指向最左边和最右边的直线：若$y_l$小于$y_r$的高度，则将l向右移(所有l和r-n的直线的面积都会小于(l,r)，因为$\Delta x$变小同时$min(y_l,y_r-n)$小于或等于$y_l$)；同理，若$y_r$小于$y_l$的高度，则将r向左移。每次移动后更新最大面积。最后时间复杂度是O(N)。这里有[图示](https://discuss.leetcode.com/topic/3462/yet-another-way-to-see-what-happens-in-the-o-n-algorithm)。

{% highlight python linenos %}
class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        l,r = 0, len(height)-1
        maxArea = (r-l)*min(height[l],height[r])
        while(l<r):
            area = (r-l)*min(height[l],height[r])
            if area > maxArea:
                maxArea = area
                
            if (height[l] < height[r]):
                l += 1
            else:
                r -= 1
        return maxArea
{% endhighlight %}


### (15) 3Sum ###

**3Sum**: Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. 

<blockquote>
<strong>For example</strong><br> 
given array S = [-1, 0, 1, 2, -1, -4],<br>
A solution set is:<br>
[<br>
  [-1, 0, 1],<br>
  [-1, -1, 2]<br>
] 
</blockquote>

分析：本题是**KSUM系列**。蛮力法是3重遍历，复杂度是$O(N^3)$，这里就不赘述了。这里我们介绍两种方法。第一种复杂度是$O(N^2logN)$，先将数组排序，然后双重嵌套，再用二分法找第三个数(-(nums[i]+nums[j]))，注意要去重。第二种方法复杂度是$O(N^2)$，先将数组排序$O(NlogN)$，然后从小到大进行**2SUM**问题。而排序好的**2SUM**可以用$O(N)$双重指针来实现(``l=i+1,r=len(nums)-1``，当相加小于target，则``l+=1``，若大于，则``r-=1``)。

{% highlight python linenos %}
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums = sorted(nums)
        result = []
        for i in range(len(nums)):
            if i > 0 and nums[i-1]==nums[i]: continue
            l,r = i+1,len(nums)-1
            target = - nums[i]
            while(l < r):
                if nums[l]+nums[r] == target:
                    ans = [nums[i],nums[l],nums[r]]
                    result.append(ans)
                    while l < r and nums[l] == nums[l+1]: l += 1
                    while l < r and nums[r-1] == nums[r]: r -= 1
                    l += 1
                    r -= 1
                elif nums[l]+nums[r] < target:
                    l += 1
                else:
                    r -= 1
        return result
{% endhighlight %}



### (16) 3Sum Closest ###

**3Sum Closest**: Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. 

<blockquote>
<strong>For example</strong><br> 
given array S = {-1 2 1 -4}, and target = 1,<br>
The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).<br>
</blockquote>



分析：本题是**KSUM系列**，和15题类似。关键是双指针要步步逼近target，不能有遗漏的case。在这过程中update最接近的值，若match则立即返回。

{% highlight python linenos %}
class Solution(object):
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        nums = sorted(nums)
        result = nums[0]+nums[1]+nums[2]
        for i in range(len(nums)-1):
            l,r = i+1, len(nums)-1
            while(l < r):
                sum = nums[i] + nums[l] + nums[r]
                if abs(target-sum) < abs(target-result): # update closest result
                    result = sum

                if sum == target:
                    result = sum
                    return result
                elif sum < target:
                    l += 1
                elif sum > target:
                    r -= 1
        return result
{% endhighlight %}



## Chapter 2 排序 ##

## Chapter 3 搜索 ##

### (1) Two Sum ###

**Two Sum**: Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. 

<blockquote>
<strong>For example</strong><br> 
Given nums = [2, 7, 11, 15], target = 9,<br>
Because nums[0] + nums[1] = 2 + 7 = 9, <br>
return [0, 1].
</blockquote>

分析：本题的本质是**搜索**。因此读取array时，将array存储为key(大小),value(位置)的HashTable。从数组左边scan到右边，当发现有与当前整数相加等于target的key(HashTable查找key平均是O(1)复杂度)时，返回相应位置；否则加入HashTable。

{% highlight python linenos %}
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        entries,i = dict(), 0
        for x in nums:
            compl = target - x
            if compl in entries:
                return [i, entries[compl]]
            else:
                entries[x],i = i,i+1
        return [0,0]
{% endhighlight %}

### (4) Median of Two Sorted Arrays ###

**Median of Two Sorted Arrays**: There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

<blockquote>
<strong>Example1</strong><br> 
nums1 = [1, 3],<br>
nums2 = [2], <br>
The median is 2.0 <br> <br>
<strong>Example2</strong><br> 
nums1 = [1, 2],<br>
nums2 = [3, 4], <br>
The median is 2.5
</blockquote>

分析：乍一看，这其实是一个归并+取中位数的问题。依据归并算法，两个排序号的子数组merge，复杂度是O(M+N)，可以实现。那么如何实现O(log(m+n))的复杂度呢，关键是要分析中位数的性质，具体参考[这里](https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation)。


{% highlight python linenos %}
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        i = j = 0
        merged = []
        while(i < len(nums1) or (j < len(nums2))):
            if i >= len(nums1):
                merged.append(nums2[j])
                j += 1
            elif j >= len(nums2):
                merged.append(nums1[i])
                i +=1
            elif(nums1[i] <= nums2[j]):
                merged.append(nums1[i])
                i += 1
            elif(nums1[i] > nums2[j]):
                merged.append(nums2[j])
                j += 1
        isOdd = len(merged)%2 == 0
        print(isOdd)
        print(merged)
        if isOdd:
            index = len(merged)//2
            return (merged[index] + merged[index-1])/2
        else:
            return merged[len(merged)//2]
{% endhighlight %}

## Chapter 4 图 ##

## Chapter 5 字符串 ##

### (5) Longest Palindromic Substring ###

**Longest Palindromic Substring**:Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

<blockquote>
<strong>Example1</strong><br> 
Input: "babad",<br>
Output: "bab", <br>
Note: "aba" is also a valid answer. <br> <br>
<strong>Example2</strong><br> 
Input: "cbbd",<br>
Output: "bb".
</blockquote>

分析：本题本质是string的操作。思路比较单一，就是遍历每个字符，对字符c的左右进行匹配，直到左右不相等，记录最长的长度和左边起始位置。tricky的地方是需要考虑回文是偶数个还是基数个的情况。

{% highlight python linenos %}
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        self.start = 0
        self.length = 1
        def checkPal(l,r):
            while(l >= 0 and r <=len(s)-1 and s[l]==s[r]):
                l -=1
                r +=1
            if(r-l-1 > self.length):
                self.length = r-l-1
                self.start = l + 1
        for i in range(len(s)-1):
            checkPal(i,i)
            checkPal(i,i+1)

        return s[self.start:self.start+self.length]

{% endhighlight %}

### (14) Longest Common Prefix ###

**Longest Palindromic Substring**:Write a function to find the longest common prefix string amongst an array of strings

<blockquote>
<strong>Example1</strong><br> 
Input: ["a","a","b"],<br>
Output: "", <br>
<strong>Example2</strong><br> 
Input: ["a","a"],<br>
Output: "a".
</blockquote>

分析：本题本质是string的操作和函数式的应用。刚开始以为找两两之间最长的LCP，后来才发现应该是所有字符串的LCP，感觉题目没说清楚。

{% highlight python linenos %}
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        def lcp(s1,s2):
            if len(s1) > len(s2):
                s1, s2 = s2, s1
            for i in range(len(s1)):
                if(s1[i]!=s2[i]):
                    return s1[:i]
            return s1
        return reduce(lcp,strs) if strs else ""
{% endhighlight %}

## Chapter 6 Context ##




## 5 参考资料 ##
- [Algorithm](http://algs4.cs.princeton.edu/home/);

- [Visualize Algorithm](http://visualgo.net/);

- [1.1 从N个数字里找出最小的k个](http://www.ardendertat.com/2011/05/30/my-favorite-interview-question/);

## 6 template ##

### (5) Longest Palindromic Substring ###

**Longest Palindromic Substring**:Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

<blockquote>
<strong>Example1</strong><br> 
Input: "babad",<br>
Output: "bab", <br>
Note: "aba" is also a valid answer. <br> <br>
<strong>Example2</strong><br> 
Input: "cbbd",<br>
Output: "bb".
</blockquote>

{% highlight python linenos %}
class Solution(object):

{% endhighlight %}



