---
layout: post
title: Go Review
categories: [00 Go]
tags: [C]
number: [0.1]
fullview: false
shortinfo: 本文是对《The Go Programming Language》的总结。

---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## 1 Go ##

### 1.0 Basics

### 1.1 Strings
#### 1.1.1 Basic String Operation
{% highlight go linenos %}
// The standard library's `strings` package provides many
// useful string-related functions. Here are some examples
// to give you a sense of the package.

package main

import s "strings"
import "fmt"

// We alias `fmt.Println` to a shorter name as we'll use
// it a lot below.
var p = fmt.Println

func main() {

    // Here's a sample of the functions available in
    // `strings`. Since these are functions from the
    // package, not methods on the string object itself,
    // we need pass the string in question as the first
    // argument to the function. You can find more
    // functions in the [`strings`](http://golang.org/pkg/strings/)
    // package docs.
    p("Contains:  ", s.Contains("test", "es"))
    p("Count:     ", s.Count("test", "t"))
    p("HasPrefix: ", s.HasPrefix("test", "te"))
    p("HasSuffix: ", s.HasSuffix("test", "st"))
    p("Index:     ", s.Index("test", "e"))
    p("Join:      ", s.Join([]string{"a", "b"}, "-"))
    p("Repeat:    ", s.Repeat("a", 5))
    p("Replace:   ", s.Replace("foo", "o", "0", -1))
    p("Replace:   ", s.Replace("foo", "o", "0", 1))
    p("Split:     ", s.Split("a-b-c-d-e", "-"))
    p("ToLower:   ", s.ToLower("TEST"))
    p("ToUpper:   ", s.ToUpper("test"))
    p()

    // Not part of `strings`, but worth mentioning here, are
    // the mechanisms for getting the length of a string in
    // bytes and getting a byte by index.
    p("Len: ", len("hello"))
    p("Char:", "hello"[1])
}
{% endhighlight %} 

### 1.2 Slice

### 1.3 Map

{% highlight go linenos %}
t := []string{"g", "h", "i"}
s := make([]string, 3)
{% endhighlight %} 

### 1.4 Range

### 1.5 Func

### 1.6 Struct

initialize a new struct with field

{% highlight go linenos %}
type argError struct {
	num  int
	prob string
}
e := &argError{42, "argError happens"}
{% endhighlight %} 

in golang, `Captical` struct field will be seen outside of the struct and `noncapitcal` struct field will not be seen outside  of the strcut, see below for illustration

{% highlight go linenos %}
type Apple1 struct {
    color string
    weight int
}

a := json.Marshal(Apple1{"green", 10})
fmt.Println(a) // {}

type Apple2 struct {
    Color string
    Weight int
}

a := json.Marshal(Apple{"green", 10})
fmt.Println(a) // {"Color": "green", "Weight": 10}
{% endhighlight %} 


### 1.7 Methods

> A NON-POINTER receiver works with value POINTER or NON-POINTER; A POINTER receiver only works with value that is POINTER.

### 1.8 Interface


### 1.9 Error

### 1.10 Goroutine

### 1.11 Channels

#### 1.11.1 Unbuffered Channel

> **Channel** is the pipe to connect different goroutines. You can send values into channels from one goroutine and receive those values into another goroutine. By default sends and receives block until both the sender and receiver are ready

{% highlight go linenos %}
func main() { // main goroutine
	messageChannel := make(chan string)
	go func() { // spawned goroutine
		messageChannel <- "ping"
	}()
	res := <-messageChannel
	fmt.Println(res)
}
{% endhighlight %} 

#### 1.11.2 Buffered Channel

> **Buffered Channels**: sender will not block if the receiver is not ready; sender will only be blocked if the buffer is full. receiver is not blocked if the sender is not ready; the receiver will only be blocked if the buffer is empty.

#### 1.11.3 Directional Channel

{% highlight go linenos %}

// sender and receiver 流向,  info <-chan   chan <- info
func ping(pings chan<- string, msg string) { // sender channel,           
	pings <- msg  //给sender channel装上
}

func pong(pings <-chan string, pong chan<- string) {
	msg := <-pings  //receiver channel取下
	pong <- msg
}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)
	ping(pings, "passed message")
	pong(pings, pongs)
	fmt.Println(<-pongs)
}

{% endhighlight %} 

#### 1.11.4 Select

{% highlight go linenos %}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)

	go func() {
		time.Sleep(5 * time.Second)
		pings <- "info1"
	}()
	go func() {
		time.Sleep(5 * time.Second)
		pongs <- "info2"
	}()
	start := time.Now()
	for i := 0; i < 2; i++ {
		select {
		case msg1 := <-pings:
			fmt.Println(msg1)
		case msg2 := <-pongs:
			fmt.Println(msg2)
		}
	}
	finish := time.Now()
	delta := finish.Sub(start)
	fmt.Println("end: ", delta)
}

{% endhighlight %} 

use select to timeout

{% highlight go linenos %}

func main() {
	pings := make(chan string, 1)

	go func() {
		time.Sleep(5 * time.Second)
		pings <- "info1"
	}()

	select {
	case msg1 := <-pings:
		fmt.Println(msg1)
	case <-time.After(time.Second):
		fmt.Println("timeout")
	}
}

{% endhighlight %} 

a non-blocking channel realized by default in select

{% highlight go linenos %}

func main() {
	pings := make(chan string, 1)
	pings <- "Hi"
	select {
	case msg1 := <-pings:
		fmt.Println(msg1)
	default:
		fmt.Println("no message receiveds")
	}
}


{% endhighlight %} 

#### 1.11.5 Close Channel

{% highlight go linenos %}

func main() {
	pings := make(chan int)
	done := make(chan bool)

	go func() {
		for {
			j, isOpen := <-pings
			if isOpen {
				fmt.Println("receving: ", j)
			} else {
				<-done
				fmt.Println("Done")
			}
		}
	}()

	for i := 0; i < 3; i++ {
		pings <- i
	}
	fmt.Println("1")
	close(pings)
	fmt.Println("2")
	done <- true
	fmt.Println("3")
}

{% endhighlight %}

range over buffered channel
{% highlight go linenos %}
func main() {
	pings := make(chan string, 2)

	pings <- "info1"
	pings <- "info2"
	close(pings)

	for i := range pings {
		fmt.Println("receiving", i)
	}

	fmt.Println("end")
}
{% endhighlight %} 



#### 1.11.6 Channel Use Cases


{% highlight go linenos %}
{% endhighlight %} 


##### 1.11.6.1 Synchronization

Use channel to let one goroutine(below is the main goroutine wait for the spawned goroutine - notifier) wait for another goroutine to finish.

{% highlight go linenos %}
func notifier(done chan bool) {
	fmt.Println("start notifier")
	time.Sleep(time.Second * 5)
	done <- true
	fmt.Println("notifier send true")
}

func main() {

	done := make(chan bool)
	go notifier(done)
	<-done
	fmt.Println("main finished")
}
{% endhighlight %} 

##### 1.11.6.2 Worker Pool

{% highlight go linenos %}
func main() { // main goroutine
	jobsChan := make(chan int, 100)
	resChan := make(chan int, 100)

	for i := 0; i < 3; i++ {
		go worker(i, jobsChan, resChan)
	}

	for j := 0; j < 5; j++ {
		jobsChan <- j
	}
	close(jobsChan)
	
	for j := 0; j < 5; j++ {
		<-resChan
	}
  /* for j := resChan { this will cause deadlock, why?
    fmt.Println(j)
  }
  */
}
{% endhighlight %} 

##### 1.11.6.2 Rate Limiting

{% highlight go linenos %}
{% endhighlight %}

##### 1.11.6.3 Atomic Counter

{% highlight go linenos %}
import (
	"fmt"
	"sync/atomic"
	"time"
)

func main() { // main goroutine
	var ops uint64
	for i := 0; i < 50; i++ {
		go func() {
			for {
				atomic.AddUint64(&ops, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}
	time.Sleep(time.Second)
	opsFinal := atomic.LoadUint64(&ops)
	fmt.Println("ops", opsFinal)
}
{% endhighlight %}



## 2 Basic Algo

### 2.1 Sort

1. `sort.Strings(strs)`, `sort.Ints(ints)`, `sort.IntsAreSorted(ints)`

2. sort by function

{% highlight go linenos %}
package main

import "sort"
import "fmt"

// In order to sort by a custom function in Go, we need a
// corresponding type. Here we've created a `byLength`
// type that is just an alias for the builtin `[]string`
// type.
type byLength []string

// We implement `sort.Interface` - `Len`, `Less`, and
// `Swap` - on our type so we can use the `sort` package's
// generic `Sort` function. `Len` and `Swap`
// will usually be similar across types and `Less` will
// hold the actual custom sorting logic. In our case we
// want to sort in order of increasing string length, so
// we use `len(s[i])` and `len(s[j])` here.
func (s byLength) Len() int {
    return len(s)
}
func (s byLength) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}
func (s byLength) Less(i, j int) bool {
    return len(s[i]) < len(s[j])
}

// With all of this in place, we can now implement our
// custom sort by casting the original `fruits` slice to
// `byLength`, and then use `sort.Sort` on that typed
// slice.
func main() {
    fruits := []string{"peach", "banana", "kiwi"}
    sort.Sort(byLength(fruits))
    fmt.Println(fruits)
}
{% endhighlight %} 

### 2.2 Searching

#### 2.2.1 Hashing

{% highlight go linenos %}
// Go implements several hash functions in various
// `crypto/*` packages.
import "crypto/sha1"
import "fmt"

func main() {
    s := "sha1 this string"

    // The pattern for generating a hash is `sha1.New()`,
    // `sha1.Write(bytes)`, then `sha1.Sum([]byte{})`.
    // Here we start with a new hash.
    h := sha1.New()

    // `Write` expects bytes. If you have a string `s`,
    // use `[]byte(s)` to coerce it to bytes.
    h.Write([]byte(s))

    // This gets the finalized hash result as a byte
    // slice. The argument to `Sum` can be used to append
    // to an existing byte slice: it usually isn't needed.
    bs := h.Sum(nil)

    // SHA1 values are often printed in hex, for example
    // in git commits. Use the `%x` format verb to convert
    // a hash results to a hex string.
    fmt.Println(s)
    fmt.Printf("%x\n", bs)
}
{% endhighlight %} 

## 3 Infra

### 3.0 IO(`os`,`ioutil`,`bufio`)

#### 3.0.1 Reading

#### 3.0.2 Writing

#### 3.0.3 Line Filter


{% highlight go linenos %}
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)

	for scanner.Scan() {
		ucl := strings.ToUpper(scanner.Text())
		fmt.Println(ucl)
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error: ", err)
		os.Exit(1)
	}
}
{% endhighlight %} 
使用
{% highlight go linenos %}
$ echo 'hello'   > /tmp/lines
$ echo 'filter' >> /tmp/lines	
$ cat /tmp/lines | go run line-filters.go
HELLO
FILTER
{% endhighlight %} 

### 3.1 Panic

exit program with status 2

### 3.2 Defer

{% highlight go linenos %}
// _Defer_ is used to ensure that a function call is
// performed later in a program's execution, usually for
// purposes of cleanup. `defer` is often used where e.g.
// `ensure` and `finally` would be used in other languages.

package main

import "fmt"
import "os"

// Suppose we wanted to create a file, write to it,
// and then close when we're done. Here's how we could
// do that with `defer`.
func main() {

    // Immediately after getting a file object with
    // `createFile`, we defer the closing of that file
    // with `closeFile`. This will be executed at the end
    // of the enclosing function (`main`), after
    // `writeFile` has finished.
    f := createFile("/tmp/defer.txt")
    defer closeFile(f)
    writeFile(f)
}

func createFile(p string) *os.File {
    fmt.Println("creating")
    f, err := os.Create(p)
    if err != nil {
        panic(err)
    }
    return f
}

func writeFile(f *os.File) {
    fmt.Println("writing")
    fmt.Fprintln(f, "data")

}

func closeFile(f *os.File) {
    fmt.Println("closing")
    f.Close()
}
{% endhighlight %} 





### 3.2 `reflect`

1. `reflect.TypeOf(aVar)` vs `reflect.TypeOf(aVar).Kind()`;

### 3.3 `regexp`

{% highlight go linenos %}
import "bytes"
import "fmt"
import "regexp"

func main() {

    // This tests whether a pattern matches a string.
    match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    fmt.Println(match)
}
{% endhighlight %} 

### 3.4 `encoding/json`

{% highlight go linenos %}
import (
	"encoding/json"
	"fmt"
)
type response1 struct {
	Page   int
	Fruits []string
}

func main() {
	res1D := &response1{
		Page:   1,
		Fruits: []string{"apple", "peach", "pear"}}
	res1B, _ := json.Marshal(res1D)
	fmt.Println(string(res1B))

	str := `{"Page": 1, "Fruits": ["apple", "peach"]}`
	res := response1{}
	json.Unmarshal([]byte(str), &res)
	fmt.Println(res)
}
{% endhighlight %} 

### 3.5 `time`

#### 3.5.0 Basic time

{% highlight go linenos %}
import (
	"fmt"
	"reflect"
	"time"
)

func main() {
	p := fmt.Println

	now := time.Now()
	p(now)
	then := time.Date(
		2009, 11, 17, 20, 34, 58, 36812763812638, time.UTC)
	p(then)
	p(then.Year())
	p(then.Month())
	p(then.Day())
	p(then.Hour())
	p(then.Minute())
	p(then.Second())
	p(then.Nanosecond())
	p(then.Location())

	p(then.Weekday())
	p(then.Before(now))
	p(then.After(now))
	p(then.Equal(now))

	diff := now.Sub(then)
	p("diff", reflect.TypeOf(diff))
	p(diff)

	p(diff.Hours())
	p(diff.Minutes())


	secs := time.Now().Unix()
	p("time to epoch: ", secs)               // 1541217165
	p("epoch to time: ", time.Unix(secs, 0)) // 2018-11-03 11:52:45 +0800 HKT
}
{% endhighlight %} 


#### 3.5.1 Timer

> Timer: Timers are for when you want to do something once in the future

{% highlight go linenos %}

	timer1 := time.NewTimer(2 * time.Second)

	<-timer1.C
	fmt.Println("Timer 1 expired")

	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 expired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

{% endhighlight %}



#### 3.5.2 Ticker

> Tickers are for when you want to do something repeatedly at regular intervals.

{% highlight go linenos %}
func main() { // main goroutine
	ticker := time.NewTicker(500 * time.Millisecond)
	go func() {
		for t := range ticker.C {
			fmt.Println("Tick at", t)
		}
	}()

	time.Sleep(1600 * time.Millisecond)
	ticker.Stop()
	fmt.Println("Ticker stopped")
}
{% endhighlight %} 

### 3.6 `math/rand`

{% highlight go linenos %}
import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	p := fmt.Println
	// each time run, it produce the same sequence
	p(rand.Intn(100), ",")
	p(rand.Intn(100))
	p(rand.Float64())
	// in order to produce different sequence, you need provide a seed. Time is a good seed
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	p(r1.Intn(100))
}
{% endhighlight %} 


### 3.7 `strconv`

{% highlight go linenos %}
import (
	"fmt"
	"strconv"
)

func main() {
	p := fmt.Println

	f, _ := strconv.ParseFloat("1.234", 64)
	p(f)

	i, _ := strconv.ParseInt("123", 0, 64)
	p(i)

	k, _ := strconv.Atoi("135")
	p(k)

	l, _ := strconv.Atoi("wat")
	p(l)
}
{% endhighlight %}


### 3.8 `net/url`

{% highlight go linenos %}
import "fmt"
import "net"
import "net/url"

func main() {
    s := "postgres://user:pass@host.com:5432/path?k=v#f"

    u, err := url.Parse(s)
    if err != nil {
        panic(err)
    }

    fmt.Println(u.Scheme)
    fmt.Println(u.User)
    fmt.Println(u.User.Username())
    p, _ := u.User.Password()
    fmt.Println(p)
    fmt.Println(u.Host)
    host, port, _ := net.SplitHostPort(u.Host)
    fmt.Println(host)
    fmt.Println(port)
    fmt.Println(u.Path)
    fmt.Println(u.Fragment)
    fmt.Println(u.RawQuery)
    m, _ := url.ParseQuery(u.RawQuery)
    fmt.Println(m)
    fmt.Println(m["k"][0])
}
{% endhighlight %} 



### 3.8 `os`

#### 3.8.1 command line args
{% highlight go linenos %}
func main() {
	argsWithProg := os.Args
	argsWithoutProg := os.Args[1:]

	arg := os.Args[3]

	fmt.Println(argsWithProg)
	fmt.Println(argsWithoutProg)
	fmt.Println(arg)
}
{% endhighlight %} 


{% highlight go linenos %}
{% endhighlight %} 

#### 3.8.1.1 command line `flag`

{% highlight go linenos %}
import (
	"flag"
	"fmt"
)

func main() {
	wordPtr := flag.String("word", "foo", "a string")
	numbPtr := flag.Int("num", 42, "an int")

	flag.Parse()

	fmt.Println("word: ", *wordPtr)
	fmt.Println("numb: ", *numbPtr)
}
{% endhighlight %} 

### 3.8.2 Env

{% highlight go linenos %}
import (
	"fmt"
	"os"
	"strings"
)

func main() {
	os.Setenv("FOO", "1")
	fmt.Println("FOO: ", os.Getenv("FOO"))
	for _, e := range os.Environ() {
		pair := strings.Split(e, "=")
		fmt.Println(pair[0])
	}
}
{% endhighlight %} 

### 3.8.3 Process

#### 3.8.3.1 Spawn a process

Spawn an external process, and make it accessible through the parent go process

{% highlight go linenos %}
import (
	"fmt"
	"os/exec"
)

func main() {
	dateCmd := exec.Command("date")
	dateOut, err := dateCmd.Output()
	if err != nil {
		panic(err)
	}
	fmt.Println("> date")
	fmt.Println(string(dateOut))
}
{% endhighlight %}

#### 3.8.3.2 Exec a process

Exec an external process to relace the current go process

{% highlight go linenos %}
import "syscall"
import "os"
import "os/exec"

func main() {
	binary, lookErr := exec.LookPath("ls")
	if lookErr != nil {
		panic(lookErr)
	}
	args := []string{"ls", "-a", "-l", "-h"}
	env := os.Environ()
	execErr := syscall.Exec(binary, args, env)
	if execErr != nil {
		panic(execErr)
	}
}

{% endhighlight %}

#### 3.8.4 Signal `os/signal`, `syscall`

{% highlight go linenos %}
// Sometimes we'd like our Go programs to intelligently
// handle [Unix signals](http://en.wikipedia.org/wiki/Unix_signal).
// For example, we might want a server to gracefully
// shutdown when it receives a `SIGTERM`, or a command-line
// tool to stop processing input if it receives a `SIGINT`.
// Here's how to handle signals in Go with channels.

package main

import "fmt"
import "os"
import "os/signal"
import "syscall"

func main() {

	// Go signal notification works by sending `os.Signal`
	// values on a channel. We'll create a channel to
	// receive these notifications (we'll also make one to
	// notify us when the program can exit).
	sigs := make(chan os.Signal, 1)
	done := make(chan bool, 1)

	// `signal.Notify` registers the given channel to
	// receive notifications of the specified signals.
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	// This goroutine executes a blocking receive for
	// signals. When it gets one it'll print it out
	// and then notify the program that it can finish.
	go func() {
		sig := <-sigs
		fmt.Println()
		fmt.Println(sig)
		done <- true
	}()

	// The program will wait here until it gets the
	// expected signal (as indicated by the goroutine
	// above sending a value on `done`) and then exit.
	fmt.Println("awaiting signal")
	<-done
	fmt.Println("exiting")
}

{% endhighlight %} 


#### 3.8.4 Exit

Note that unlike e.g. C, Go does not use an integer return value from main to indicate exit status. If you’d like to exit with a non-zero status you should use os.Exit.

{% highlight go linenos %}

import "fmt"
import "os"

func main() {
	defer fmt.Println("!")
	os.Exit(3)
}

{% endhighlight %}

## A1

{% highlight go linenos %}
{% endhighlight %} 



### A1.1 make function

> **make**, a built-in function to take a type T, which must be a slice, map or channel type,


## A2 Go problems

### A2.1 Go doesn't support generic

## 4 总结 ##

{: .img_middle_hg}
![Network overview](/assets/images/posts/2014-06-01-C Review/Chapter 14 The Preprocessor.png)


## 5 Reference ##

- [《The Go Programming Language》](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440);

- [《Go Documenation》](https://golang.org/doc/)

- [《Go Package](https://golang.org/pkg/)

- [《Effective Go](https://golang.org/doc/effective_go.html)



