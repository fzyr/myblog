---
layout: post
title: Go Review
categories: [00 Go]
tags: [C]
number: [0.1]
fullview: false
shortinfo: 本文是对《The Go Programming Language》的总结。

---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## 1 Go ##

### 1.0 Basics

0. Go's `type` fall into 4 categories:
	- **basic type**: number(`int`, `int8 uint8(byte, indicates its a raw data instead of numeric data)`, `int16 uint16`, `int32 uint32(rune, indicates its a unicode code point)`, `int64 uint64`; `float32`, `float64`; `complex64`, `complex128`), `string`, `bool`;
	- **aggregate type**: pointer, `array`, `struct`;
	- **reference type**: `slice`, `map`, `chan`, `func`;
	- **interface type**: `interface`.

1. No semicolons are needed, go just convert newlines into semicolons. So where newlines are placed matters to proper parsing of Go code. For example, the `}` should be on the same line as last character.

2. `s := ""`, `var s string`: the first says the initial value is important, the second says it is a string and initial value doesn't matter, thought it is initialized to `""`. These are the only two recommended forms to declare vars in go.

3. `bufio`, `ioutil` builds on top of `Read` and `Write` methods of `*io.File`. `bufio` buffers input and once full, will call `*io.File.Write()` once, thus reduce Write to OS to improve performance.

4. ```package main
	const a = 212.0
``` `a` is visible through `package main`.

5. `i, j =j, i //swap values of i and j`.

6. Short Variable declaration, `in, err := os.Open(inFile)` and `out, err := os.Open(outFile)` will reassign err in second line of code. Short Variable declaration require each time at least one new variable is delcared, which means `f, err := os.Open(inFile)` and `f, err := os.Open(outFile)` will not work.

### 1.1 Basic type

#### 1.1.1 `int`

#### 1.1.2 `float`

#### 1.1.3 `complex`

#### 1.1.4 `bool`

#### 1.1.5 `string`

##### 1.1.5.1 `strings` for searching, replacing, comparing, trimming, splitting and joining strigns
{% highlight go linenos %}
// The standard library's `strings` package provides many
// useful string-related functions. Here are some examples
// to give you a sense of the package.

package main

import s "strings"
import "fmt"

// We alias `fmt.Println` to a shorter name as we'll use
// it a lot below.
var p = fmt.Println

func main() {

		// Here's a sample of the functions available in
		// `strings`. Since these are functions from the
		// package, not methods on the string object itself,
		// we need pass the string in question as the first
		// argument to the function. You can find more
		// functions in the [`strings`](http://golang.org/pkg/strings/)
		// package docs.
		p("Contains:  ", s.Contains("test", "es"))
		p("Count:     ", s.Count("test", "t"))
		p("HasPrefix: ", s.HasPrefix("test", "te"))
		p("HasSuffix: ", s.HasSuffix("test", "st"))
		p("Index:     ", s.Index("test", "e"))
		p("Join:      ", s.Join([]string{"a", "b"}, "-"))
		p("Repeat:    ", s.Repeat("a", 5))
		p("Replace:   ", s.Replace("foo", "o", "0", -1))
		p("Replace:   ", s.Replace("foo", "o", "0", 1))
		p("Split:     ", s.Split("a-b-c-d-e", "-"))
		p("ToLower:   ", s.ToLower("TEST"))
		p("ToUpper:   ", s.ToUpper("test"))
		p()

		// Not part of `strings`, but worth mentioning here, are
		// the mechanisms for getting the length of a string in
		// bytes and getting a byte by index.
		p("Len: ", len("hello"))
		p("Char:", "hello"[1])
}
{% endhighlight %} 

##### 1.1.5.2 `bytes` for searching, replacing, comparing, trimming, splitting and joining `[]byte`

`bytes.Buffer` is more efficient for building strings incrementally

{% highlight go linenos %}
{% endhighlight %} 

##### 1.1.5.3 `strconv` for converting bool, integer, floating-point values to and from string

functions:

1. `Atoi`
2. `ParseInt`

{% highlight go linenos %}
{% endhighlight %} 

##### 1.1.5.4 `unicode` for classifying rune

{% highlight go linenos %}
{% endhighlight %} 

#### 1.1.6 Constant

### 1.2 Aggregate type

#### 1.2.1 Pointer

#### 1.2.2 `array`

{% highlight go linenos %}
var q1 [3]int = [3]int{1,2,3}
q2 := [...]int{1,2,3} // the size of q is determined by the number of initializers.
var q3 [3]int
var q4 [4]int // q3 and q4 are two different types
{% endhighlight %}

#### 1.2.3 `struct`

##### 1.2.3.1 basics

initialize a new struct pointer with field

{% highlight go linenos %}
type argError struct {
	num  int
	prob string
}
e := &argError{42, "argError happens"}
{% endhighlight %} 

in golang, `Captical` struct field will be seen outside of the struct and `noncapitcal` struct field will not be seen outside  of the strcut, see below for illustration

{% highlight go linenos %}
type Apple1 struct {
		color string
		weight int
}

a := json.Marshal(Apple1{"green", 10})
fmt.Println(a) // {}

type Apple2 struct {
		Color string
		Weight int
}

a := json.Marshal(Apple{"green", 10})
fmt.Println(a) // {"Color": "green", "Weight": 10}
{% endhighlight %} 


Composed types by struct embedding can access nested field directly from the top struct

{% highlight go linenos %}
type Point struct{X,Y float64}
type ColoredPoint struct{
	Point
	Color color.RGBA
}
colorPoint.X // no need to use colorPoint.Point.X
{% endhighlight %}

Composed types by struct embedding can access nested method directly from the top struct

{% highlight go linenos %}
red := color.RGBA{255, 0, 0, 255}
blue := color.RGBA{0, 0, 255, 255}
type Point struct{X,Y float64}
type ColorPoint struct{Point, Color color.RGBA}
method (p Point) total () {
	return p.X + p.Y
}
cp1 := ColorPoint{Point{1,2}, red}
cp2 := ColorPoint{Point{1,2}, blue}
fmt.Println(p.Distance(q.Point)) // "5", no need to call fmt.Println(p.Point.Distance(q.Point)), but also you cannot call fmt.Println(p.Distance(q))
{% endhighlight %}

**method value** is the method binded to receiver, which is a function; **method expression** convert a method into a function which take receiver as the first parameter.

{% highlight go linenos %}
distanceFromP := p.Distance	// method value
fmt.Println(distanceFromP(q))

distance := Point.Distance   // method expression
fmt.Println(distance(p, q))  // "5"
{% endhighlight %}

Go has only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in w hich they are defined, and uncapitalized names are not.

##### 1.2.3.2 empty `struct`

{% highlight go linenos %}
done :make(chan struct{})
done <- struct{}{} // why 2 {}
{% endhighlight %}

[empty struct usage](https://dave.cheney.net/2014/03/25/the-empty-struct)

### 1.3 Reference type

#### 1.3.1 `slice`

{% highlight go linenos %}
q := [...]int{1, 2, 3}	// type: [3]int, array
// 1. slice an array produce a slice type
qs := q[0:] // type: []int, slice
// 2. literal initializer: slice(varied length) vs array(fixed length)
qs1 := []int{1,2,3} // type: []int, slice
// 3. make a slice
qs2 := make([]int, 3)	 // type: []int, slice, initizlied to int zero default value, which is 0
{% endhighlight %} 

#### 1.3.2 `map`

`counts := make(map[string]int)`or`counts :=make`, the map type is a **reference** to the underlying data structure.


{% highlight go linenos %}
t := []string{"g", "h", "i"}
s := make([]string, 3)

_ = &counts["a"] // compile error: cannot take address of map element since growing a map might cause rehashing of existing elements into new storage locations, thus potentially invalidating the address.
{% endhighlight %} 

#### 1.3.3 `func`


##### 1.3.3.1 Normal func

{% highlight go linenos %}
func add(x int, y int) int { return x + y}
func sub(x, y int) (z int) { z = x - y; return }	// z will still be returned since once this function has been called, z already alloct on the stack.
func first(x int, _ int) int { return x }
func zero(int, int) int { return 0}
{% endhighlight %} 

###### 1.3.3.1.1 `defer`

{% highlight go linenos %}
// _Defer_ is used to ensure that a function call is
// performed later in a program's execution, usually for
// purposes of cleanup. `defer` is often used where e.g.
// `ensure` and `finally` would be used in other languages.

package main

import "fmt"
import "os"

// Suppose we wanted to create a file, write to it,
// and then close when we're done. Here's how we could
// do that with `defer`.
func main() {

		// Immediately after getting a file object with
		// `createFile`, we defer the closing of that file
		// with `closeFile`. This will be executed at the end
		// of the enclosing function (`main`), after
		// `writeFile` has finished.
		f := createFile("/tmp/defer.txt")
		defer closeFile(f)
		writeFile(f)
}

func createFile(p string) *os.File {
		fmt.Println("creating")
		f, err := os.Create(p)
		if err != nil {
				panic(err)
		}
		return f
}

func writeFile(f *os.File) {
		fmt.Println("writing")
		fmt.Fprintln(f, "data")

}

func closeFile(f *os.File) {
		fmt.Println("closing")
		f.Close()
}
{% endhighlight %} 

###### 1.3.3.1.2 Variadic


{% highlight go linenos %}
func sum(vals ...int) int {
	total := 0
	for _, val := range vals {
		total += val
	}
	return total
}
{% endhighlight %} 

###### 1.3.3.1.3 `panic`

During typical panic, normal execution stops, all deferred function calls in that goroutine are executed, and the program crashes with a log message.


{% highlight go linenos %}
switch s := suit(drawCard()); s{
	case "Spades": //...
	case "Hearts": //...	
	case "Diamonds": //...}
	case "Clubs": //...
	default:
		panic(fmt.Sprintf("invalid suit %q", s))
	
}
{% endhighlight %} 


###### 1.3.3.1.4 `recover`

TBC

{% highlight go linenos %}

{% endhighlight %} 


##### 1.3.3.2 Methods

> A NON-POINTER(copy the value) receiver works with value POINTER or NON-POINTER; A POINTER(copy the address) receiver works with value that is POINTER or Non-pointer.

{% highlight go linenos %}
type Point1 struct {
	X int
	Y int
}

func (p Point1) total() int {
	return p.X + p.Y
}

func (p *Point1) totalPointer() int {
	return (*p).X + (*p).Y
}

func main() {
	p1 := Point1{1, 2}
	fmt.Println("NON-POINTER to NON-POINTER receiver", p1.total())		// 3
	fmt.Println("POINTER to NON-POINTER receiver", (&p1).total())			// 3
	fmt.Println("POINTER to POINTER receiver", (&p1).totalPointer())	// 3
	fmt.Println("NON-POINTER to POINTER receiver", p1.totalPointer())	// 3
}

{% endhighlight %} 

`fmt.Println(day.Seconds())` can you tell `day.Seconds` is an object's method or a package's function?

{% highlight go linenos %}
func (p Point)Distance(q Point) float64 {	// there is no self or this key to reference the receiver of the method, jus t use the first character of type(here p for Point) and reference p in the body.
	return math.Hypot(q.X-p.X, q.Y-p.Y)
}
fmt.Println(p.Distance(q)) // During method call, receiver appears before the method name. This parallels the declaration, in which the receiver parameter appears before the method name.
{% endhighlight %} 

Because calling a function makes a copy of each argument value, if a funciton needs to update a variable, or if an argument is so large that twe wish to avoid copying it, we must pass the address of the variable using a pointer.

In a realistic program, convention dictates that if any method of `Point` has a pointer receiver, then all methods of `Point` should have a pointer receiver, even ones that don't strictly need it.

### 1.4 interface type


#### 1.4.1 basic

The 3 common interface (pay attentionn to naming convention) in Go
{% highlight go linenos %}
package io

type Reader interface {
	Read(p []byte) (n int, err error)
}

type Writer interface {
	Write(p []byte) (n int, err error)
}
type Closer interface {
	 Close() error
}
{% endhighlight %}

one can compose interface from primitive interfaces

{% highlight go linenos %}
type ReadWriter interface {
	Reader
	Writer
}

type ReadWriteCloser interface {
	Reader
	Writer
	Closer
}

{% endhighlight %}

#### 1.4.2 type assertion

> subtype polymorphism: an interface’s methods express the similarities of the concrete types that satisfy the interface but hide the representation details and intrinsic operations of those concrete types

> ad hoc polymorphism: an interface value to hold values of a variety of concrete types and considers the interface to be the union of those types. Type assertions are used to discriminate among these types dynamically and treat each case differently.

{% highlight go linenos %}
 func sqlQuote(x interface{}) string {
		switch x := x.(type) {
			case nil:
					return "NULL"
			case int, uint:
					return fmt.Sprintf("%d", x) // x has type interface{} here.
			case bool:
				if x {
					return "TRUE"
				}
				 return "FALSE"
			case string:
					return sqlQuoteString(x) // (not shown)
			default:
					panic(fmt.Sprintf("unexpected type %T: %v", x, x))
			}
}
{% endhighlight %}


#### 1.4.2 Common interface

##### 1.4.2.1 error

{% highlight go linenos %}
type error interface {
	Error() string
}
{% endhighlight %}

##### 1.4.2.2 sort

1. `sort.Strings(strs)`, `sort.Ints(ints)`, `sort.IntsAreSorted(ints)`

2. sort by function

{% highlight go linenos %}
package main

import "sort"
import "fmt"

// In order to sort by a custom function in Go, we need a
// corresponding type. Here we've created a `byLength`
// type that is just an alias for the builtin `[]string`
// type.
type byLength []string

// We implement `sort.Interface` - `Len`, `Less`, and
// `Swap` - on our type so we can use the `sort` package's
// generic `Sort` function. `Len` and `Swap`
// will usually be similar across types and `Less` will
// hold the actual custom sorting logic. In our case we
// want to sort in order of increasing string length, so
// we use `len(s[i])` and `len(s[j])` here.
func (s byLength) Len() int {
		return len(s)
}
func (s byLength) Swap(i, j int) {
		s[i], s[j] = s[j], s[i]
}
func (s byLength) Less(i, j int) bool {
		return len(s[i]) < len(s[j])
}

// With all of this in place, we can now implement our
// custom sort by casting the original `fruits` slice to
// `byLength`, and then use `sort.Sort` on that typed
// slice.
func main() {
		fruits := []string{"peach", "banana", "kiwi"}
		sort.Sort(byLength(fruits))
		fmt.Println(fruits)
}
{% endhighlight %} 

### 1.5 Others

#### 1.5.1 Reflection

#### 1.5.2 Low-Level Programming

## 2 Concurrent Programming

### 2.1 communicating sequential processes(CSP) via`chan`

If you want share scalar value between goroutines via `chan`, just send that scalar value, which will be copied into `chan`; if you want share object bewteen groutines via `chan`, just send the address of that object, whicl will also be copied into `chan` and the receiver goroutine can do operation on that object (and normally to avoid race condition, the sender goroutine should not operate on this object any more since `csp` require at one time only one goroutine take owership of an object but that owership can be transferred across object lifecycle by sending its address via `chan` to a different goroutine). So sending arguments to a chan is the same as calling a function, which pass arguments by value.


{% highlight go linenos %}

func main() { // main goroutine
	ch = make(chan int)    // unbuffered channel
	go func() { // spawned goroutine
		messageChannel <- 1	// arguments sent to channel by value, like function invocation.
	}()
	res := <-messageChannel
	fmt.Println(res)
}
{% endhighlight %} 

#### 2.1.1 Unbuffered Channel

> **Channel** is the pipe to connect different goroutines. You can send values into channels from one goroutine and receive those values into another goroutine. By default sends and receives block until both the sender and receiver are ready

2 functions of unbuffered channels:

1. **event: synchronize goroutines**: Communication over an unbuffered channel causes the sending and receiving goroutines to synchronize. Because of this, unbuffered channels are sometimes called **synchronous channels**. When a value is sent on an unbuffered channel, the receipt of the value happens before the reawakening of the sending goroutine. 

2. **sync data: pipeline**.

{% highlight go linenos %}
ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3

func main() { // main goroutine
	messageChannel := make(chan string)
	go func() { // spawned goroutine
		messageChannel <- "ping"
	}()
	res := <-messageChannel
	fmt.Println(res)
}
{% endhighlight %} 

#### 2.1.2 Buffered Channel

> **Buffered Channels**: sender will not block if the receiver is not ready; sender will only be blocked if the buffer is full. receiver is not blocked if the sender is not ready; the receiver will only be blocked if the buffer is empty. **Buffer for channel decouples the sending and receiving goroutines.**

one can treat unbuffered channel is a special case of buffered channel with capacity 0.

{% highlight go linenos %}
cap(ch) // the capacity of the channel
len(ch) // the current length of element in the buffer.
{% endhighlight %} 

#### 2.1.3 Directional Channel

{% highlight go linenos %}

// sender and receiver 流向,  info <-chan   chan <- info
func ping(pings chan<- string, msg string) { // sender channel,           
	pings <- msg  //给sender channel装上
}

func pong(pings <-chan string, pong chan<- string) {
	msg := <-pings  //receiver channel取下
	pong <- msg
}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)
	ping(pings, "passed message")
	pong(pings, pongs)
	fmt.Println(<-pongs)
}

{% endhighlight %} 

#### 2.1.4 Multiplexing with `select`

{% highlight go linenos %}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)

	go func() {
		time.Sleep(5 * time.Second)
		pings <- "info1"
	}()
	go func() {
		time.Sleep(5 * time.Second)
		pongs <- "info2"
	}()
	start := time.Now()
	for i := 0; i < 2; i++ {
		select {
		case msg1 := <-pings:
			fmt.Println(msg1)
		case msg2 := <-pongs:
			fmt.Println(msg2)
		}
	}
	finish := time.Now()
	delta := finish.Sub(start)
	fmt.Println("end: ", delta)
}

{% endhighlight %} 

use select to timeout

{% highlight go linenos %}

func main() {
	pings := make(chan string, 1)

	go func() {
		time.Sleep(5 * time.Second)
		pings <- "info1"
	}()

	select {
	case msg1 := <-pings:
		fmt.Println(msg1)
	case <-time.After(time.Second):
		fmt.Println("timeout")
	}
}

{% endhighlight %} 

a non-blocking channel realized by default in select

{% highlight go linenos %}

func main() {
	pings := make(chan string, 1)
	pings <- "Hi"
	select {
	case msg1 := <-pings:
		fmt.Println(msg1)
	default:
		fmt.Println("no message receiveds")
	}
}


{% endhighlight %} 

an interesting select with receving and sending via one chan in its body

{% highlight go linenos %}
ch := make(chan int, 1)
for i :=0; i < 10; i++ {
	select {
		case x := <-ch:
			fmt.Println(x) // 0,2,4,6,8
		case ch <- i;
	}
}
{% endhighlight %} 

#### 2.1.5 Close Channel

{% highlight go linenos %}

func main() {
	naturals := make(chan int)
	squares := make(chan int)

	// counter
	go func() {
		for x := 0; ; x++ {
			naturals <- x
		}
	}()

	// squarer
	go func() {
		for {
			 x := <-naturals
			 squares <- x * x
		}
	}()

	// printer (in main goroutine)
	for {
		fmt.Println(<- squares)
	}
}

{% endhighlight %}


{% highlight go linenos %}
close(naturals) // close natural channel
// the squarer will still receive endless 0 values
// In order to inform squarer to stop, one can use multiple return value from channel
	go func() {
		for {
			 x, ok := <-naturals
			 if !ok {
				 break;
			 }
			 squares <- x * x
		}
	}()
{% endhighlight %} 

but it is clumsy to use ok each time and this pattern is common, go comes with a `range aChan` to stop automatically when the `aChan` has been closed 
range over buffered channel
{% highlight go linenos %}
	go func() {
		for x := range naturals {
			 squares <- x * x
		}
	}()
{% endhighlight %} 

**Close channel** has another use as a broadcast mechanism.



#### 2.1.6 Channel pitfall

##### 2.1.6.1 closure for input parameter for gorotine

{% highlight go linenos %}
func makeThumbnails(filenames []string) {
	ch := make(chan strct{})
	for _, f := range filenames {
		go func(f string) {
			thumbnail.ImageFile(f)	// Note: ignoring errors
			ch <- struct{}{}
		}(f)	// Note: here we use f as input parameter for the go anonymous function intead of reference f directly from the for loop. The reason here is that spawn a goroutine by go keyword return immediately, so once you finish spawns all the len(filenames) goroutine, the f points to the final filenames element(filename_final). When each goroutine start executing, it will point to the filename_ final instead of the f(f_atThatTime) at the time when this goroutine spawns. Using a closure would catch the f_atThatTime. 
	}
	for range filenames {
		<- ch
	}

}
{% endhighlight %} 



#### 2.1.7 Channel Use Cases


{% highlight go linenos %}
{% endhighlight %} 

##### 2.1.7.1 Looping in parallel

###### 2.1.7.1.1 for iterating from source with fixed elements, such as `slice`
> **Giving a known collection and execute in parallel**, [see 1.3.4.1.6.1 closure for input parameter for gorotine]({{ site.baseurl}}/00%20go/2014/06/01/Go-Review.html#2161-closure-for-input-parameter-for-gorotine)

###### 2.1.7.1.2 for iterating from source with unknown length of elements, such as `chan`


{% highlight go linenos %}
func makeThumbnails(filenames <-chan string) int64 {
	sizes := make(chan int64)
	var wg sync.WaitGroup
	for f := range filenames {
		wg.Add(1)
		//worker
		go func(f string) {
			defer wg.Done()
			thumb, err := thumbnail.ImageFile(f)
			if err != nil {
				log.Println(err)
				return
			}
			info, _ := os.Stat(thumb) // OK to ignore error
			sizes <- info.Size()
		}(f)

		// closer
		go func() {
			wg.Wait()
			close(sizes)
		}()
		var total int64
		for size := range sizes {
			total += size
		}
		return total
	}
}

{% endhighlight %} 

{: .img_middle_lg}
![Network overview](/assets/images/posts/00_GO/2014-06-01-Go_Review/Loop_in_parellel_with_unknown_source.png)

/Users/shunmian/Desktop/myblog/assets/images/posts/00_GO/2014-06-01-Go Review

##### 2.1.7.2 Synchronization

Use channel to let one goroutine(below is the main goroutine wait for the spawned goroutine - notifier) wait for another goroutine to finish.

{% highlight go linenos %}
func notifier(done chan bool) {
	fmt.Println("start notifier")
	time.Sleep(time.Second * 5)
	done <- true
	fmt.Println("notifier send true")
}

func main() {

	done := make(chan bool)
	go notifier(done)
	<-done
	fmt.Println("main finished")
}
{% endhighlight %} 

##### 2.1.7.3 Worker Pool

{% highlight go linenos %}
func main() { // main goroutine
	jobsChan := make(chan int, 100)
	resChan := make(chan int, 100)

	for i := 0; i < 3; i++ {
		go worker(i, jobsChan, resChan)
	}

	for j := 0; j < 5; j++ {
		jobsChan <- j
	}
	close(jobsChan)
	
	for j := 0; j < 5; j++ {
		<-resChan
	}
	/* for j := resChan { this will cause deadlock, why?
		fmt.Println(j)
	}
	*/
}
{% endhighlight %} 

##### 2.1.7.4 Rate Limiting

{% highlight go linenos %}
{% endhighlight %}

##### 2.1.7.5 Atomic Counter

{% highlight go linenos %}
import (
	"fmt"
	"sync/atomic"
	"time"
)

func main() { // main goroutine
	var ops uint64
	for i := 0; i < 50; i++ {
		go func() {
			for {
				atomic.AddUint64(&ops, 1)
				time.Sleep(time.Millisecond)
			}
		}()
	}
	time.Sleep(time.Second)
	opsFinal := atomic.LoadUint64(&ops)
	fmt.Println("ops", opsFinal)
}
{% endhighlight %}

### 2.2 shared memory multithreading

#### 2.2.1 Race condition

Concurrent issues

1. **Deadlock**;

2. **livelock**;

3. **resource starvation**;

4. **race condition**: a program does not give the correct result for some **interleaving** of the operatoins of multiple goroutines, such as g1r(v1), g2r(v1), g1w(v1+delta11), g2w(v1+delta2) => v1+delta2. The more formal definition for **data race** is whenever two goroutines access the same variable concurrently and at least one of the accesses is a write. There are 3 ways to avoid **data race**. 

##### 2.2.1.1 Solution 1: not to write varaible in function

If the `Icon` is called concurrently, there is a data race accessing the map
{% highlight go linenos %}
var icons = make(map[string]image.Image)

func loadIcon(name string) image.Image

// Note: not concurrency-safe!
func Icon(name string) image.Image {
	icon, ok := icons[name]
	if !ok {
		icon = loadIcon(name)
		icons[name] = icon
	}
	return icon
}
{% endhighlight %}

If instead we initialize the map with all necessary entries before creating additional goroutines and never modify it again, then any number of goroutines may safely call `Icon` concurrently since each only reads the map. The `icons` variable is assigned during package initialization, which happens before the program's `main` function starts running. But obviously we cannot use this approach if writes is essential, as with a bank account.

{% highlight go linenos %}
var icons = map[string]image.Image{
	"spades.png":		loadIcon("spades.png")
	"hearts.png":		loadIcon("hearts.png")
	"diamonds.png":	loadIcon("diamonds.png")
	"clubs.png":		loadIcon("clubs.png")	
}
{% endhighlight %}

##### 2.2.1.2 Solution 2: via `chan` to avoid accessing the variable from multiple goroutines

[See CSP]({{ site.baseurl}}/00%20go/2014/06/01/Go-Review.html#21-communicating-sequential-processescsp-viachan)

Only access the variable from one goroutine(**Motinor goroutine for that varaible**) and other goroutine must use channel to send a request to the **Monitor goroutine** to update the variable. This is what go's philosophy that**"Do not communicate by sharing memory; instead, share memory by communicating"** for concurrency programming means. 

{% highlight go linenos %}
var deposits = make(chan int)	// send amount to deposit
var balances = make(chan int) // receive balance

func Deposit(amount int) { deposits <- amount }
func Balance() int 			 { return <- balances }

func teller() {	
	var balance int	// balance is confined to teller goroutine
	for {
		select {
			case amount := <- deposits:
				balance += amount
			case balances <- balance
		}
	}
}

func init() {
	go teller()	// start the monitor goroutine
}

{% endhighlight %}

Even when a variable cannot be confined to a single goroutine for its entire lifetime, confinement may still be a solution the the problem of concurrent access. What you need to do is just change the monitoring goroutine by passing the address of the variable during different stages of lifecycle of the variable. But make sure there is only one monitoring goroutine during each stage. This method is called **serial confinement**.

{% highlight go linenos %}
type Cake struct{ state string }

func baker(cooked chan<- *Cake) {
	for {
		cake := new(Cake)
		cake.state = "cooked"
		cooked <- cake // baker never touches this cake again
	}
}

func icer(iced chan<- *Cake, cooked <-chan *Cake) {
	for cake := range cooked {
		cake.state = "iced"
		iced <- cake // icer never touches this cake again
	}
}
{% endhighlight %}

##### 2.2.1.3 Solution 3: via `sync.Mutex` to allow multiple goroutines to access the variable but only one at a time

Below is a binary sempahore realized by `buffered chan` with 1 capacity.

{% highlight go linenos %}
var (
	sema = make(chan struct{}, 1)	// a binary semaphore guarding balance
	balance int
)

func Deposit(amount int) {
	sema <- struct {}{}	// acquire token
	balance = balance + amount
	<-sema	// release token
}

func Balance() int {
	sema <- struct{}{}	// acquire token
	b := balance
	<-sema // release token
	return b
}

{% endhighlight %}

This pattern is so common so that `go` implement it directly by `sync.Mutex`

###### 2.2.1.3.1 `sync.Mutx`

{% highlight go linenos %}
var (
	mu = sync.Mutex	// guards balance
	balance int
)

func Deposit(amount int) {
	mu.Lock()
	balance = balance + amount
	mu.Unlock()
}

func Balance() int {
	mu.Lock()
	b := balance
	mu.Unlock()
	return b
}
{% endhighlight %}

One can use `defer mu.Unlock`, which will run even if the critical section panics, which may be important in programs that make use of `recover`. A `defer` is marginally more expensive than an explicit call to unlock, but not enough to justify less clear code. As always with concurrent programs, favor clarity and resist premature optimization. Where possible, use `defer` and let critical sections extend to the end of a function.

{% highlight go linenos %}
func Withdraw(amount int) bool {
	mu.Lock()
	defer mu.Unlock()
	Deposit(-amount)
	if Balance() < 0 {
		Deposit(amount)
		return false // insufficient funds
	}
	return true
}
{% endhighlight %}

###### 2.2.1.3.2 `sync.RWMutx`

The `sync.Mutx` cannot allow multiple read in concurrency, which should not be since multiple reads doesn't cause indeterministic as long as during any of the read, no one write is happening. This will speed up multiple reads in parallel instead of in sequence.

The `sync.RWMutext` is designed for the above purpose.

{% highlight go linenos %}
var (
	mu = sync.RWMutex	// guards balance
	balance int
)

func Deposit(amount int) {
	mu.RLock()
	defer mu.RUnlock()
	balance = balance + amount
}

func Balance() int {
	mu.Lock()
	b := balance
	mu.Unlock()
	return b
}
{% endhighlight %}


###### 2.2.1.3.1 `sync.Once`

{% highlight go linenos %}
var loadIconsOnce sync.Once
var icons map[string]image.Image

// concurrency-safe
func Icon(name string) image.Image {
	loadIconsOnce.Do(loadIcons)
	return icons[name]
}
{% endhighlight %}

each call to `Do(loadIcons)` locks the mutex and checks the boolean variable. In the first call, in which the variable is false, Do calls `loadIcons` and  sets the variable to true. Subsequent calls do nothing, but the mutex synchronization ensures that the  effcts of `loadIcons` on memory (specifically, icons) become visible to all goroutines. Using `sync.Once` in this way, we can avoid sharing variables with other goroutines untile they have been properly constructed.

###### 2.2.1.3.1 Race Detector via cmd `-race` 

Even with the greatest of care, it's all too easy to make concurrency mistabkes. FOrtunately, the `go` runtime and toolchain are equipped with a sophisticated and easy-to-use dynamic analysis tool, the `race detector`.

Just add `-race` flag to your `go build`, `go run`, `go test`, the compiler will record all the share varaible and its corresponding read and write action along with the synchronization methods such as `(*sync.Mutex).Wait`, `(*sync.WaitGroup).Wait`.

The race detector studies this stream of events, lookin gfor cases in which one goroutine reads or wirtes a shared variable that was most recently written by a different goroutine without an intervening synchronization operation. THis indicates a concurrent access to the shared variable and thus a data race.



#### 2.2.1 Goroutines vs Threads


##### 2.2.1.1 Growable Stacks

Each OS thread has a fixed-size block of memory (often as large as 2MB) for its stakc, the work area where it saves the local variables of function calls that are in progress or temporarily suspended while another function is called. This fixed-size stack is simultaneously too much and too little. A 2MB stack would be a huge waster of memory for a little goroutine, such as one that merely waits for a `WaitGroup` then closes a channel. It's not uncommon for a Go program to create hundreds of thousands of goroutines at one time, which would be impossible with stacks this large. Yet despite their size, fixed-size stack are not always big enough for the most complex and deeply recursive of functions. Changing the fixed size can improve space efficiency and allow more threads to be created, or it can enable more deeply recursive functions, but it cannot do both.

In contrast, **a goroutine starts life with a small stakc, typically 2KB, and then grow as needed.** A goroutine's stack, like the stack of an OS thread, holds the local variables of active and suspended function calls, but unlike an OS thread, a goroutine's stack is not fixed; it grows and shrinks as needed. The size limit for a goroutine stack may be as much as 1GB, orders of magnitude larger than a typical fixed-size thread stack, though of course few goroutines use that much.


##### 2.2.1.2 Goroutine Scheduling

OS threads are scheduled by the OS kernel. Every few milliseconds, a hardware timer interrupts the processor, which causes a kernel function called the `scheduler` to be invoked. This function suspends the currently executing thread and saves its registers in memory, looks over the list of threads and decides which one should run next, restores that thread's registers from memory, then resumes the execution of that thread. Because OS threads are scheduled by the kernel, passing control from one thread to another requires a **full context switch**, that is, saving the state of one user thread to memory, restoring the state of another, and updating the scheduler's data structures. This operation is slow, due to its poor locality and the number of memory accessed, and has historically only gotten worse ad the number of CPU cycles required to access memory has increased.

The Go runtime contain its own scheduler that uses a technique known as `M:N scheduling`, because it multiplexes (or schedules) m goroutines on n OS threads. The job of the Go scheduler is analogous to that of the kernel scheduler, but it is concerned only with the goroutines of a single Go program.

Unlike the operating systenm's thread scheduler, the Go scheduler is not invoked periodically by a hardware timer, but implicitly by certain Go language constructs. For example, when a goroutine calls `time.Sleep` or blocks in a channel or mutex operation, the scheduler puts it to sleep and runs another goroutine until it is time to wake the first one up. Because it doesn't need a switch to kernel context, rescheduling a goroutine is much cheaper than rescheduling a thread.

##### 2.2.1.3 `GOMAXPROCS`

The Go  scheduler uses a parameter called `GOMAXPROCS` to determine how many OS threads may be actively executing Go code simultaneously. Its default value is the number of CPUs on the machine, so on a machine with 8 CPUs will schedule Go code on up to 8 OS threads at once. (`GOMAXPROCS` is the N in M:N scheduling.) Goroutines that are sleeping or blocked in a communication do not need a thread at all. Goroutines that are blocked in I/O or other system calls or are calling non--Go functions, do need an OS thread, but `GOMAXPROCS` need not account for them.

You can explicitly  control this parameter using the `GOMAXPROCS` environment variable or the runtime.GOMAXPROCS function. We can see the effect of `GOMAXPROCS` on this little program, which prints an endless stream of zeros and ones:

{% highlight go linenos %}
for {
	go fmt.Print(0)
	fmt.Print(1)
}

$ GOMAXPROCS=1 go run main.go
1111111111111110000000000000000111111...

0101010101010101011001010100101100101...
{% endhighlight %}

In the first run, at most one goroutine was executed at a time. Initially, it was the main goroutine, which prints ones. After a period of time, the Go scheduler put it to sleep and woke up the goroutine that prints zeros, giving it a turn to run on the OS thread. In the second run, there were two OS threads available, so both goroutines ran simultaneously, printing digits at about the same rate. We must stress that many factors are involved in goroutine scheduling, and the runtime is constantly evolving, so your results may differ from the ones above

##### 2.2.1.4 Goroutine Have No Identity
 In most operating systems and programming languages that support multithreading, the current thread has a distinct identity that can be easily obtained as an oridnary value, typically an integer or pointer. This makes it easy to build an absctraction called `thread-local` storage, which is essentially a global map keyed by thread identity, so that each thread can sore and retrieve values independent of other threads.

 **Goroutines have no notion of identity that is accessible to the programmer.** This is by design, since thread-local storage tends to be abused. For example, in a web server implemented in a language with tread-local storage, it's common for many functions to find information about the HTTP request on whose behalf they are currently working by looking in that storgage. However, just as with programs that rely excessively on global vriables, this can lead to an unhealthy "action at a distance" in which the behavior of a functin si not determined by its arguments alone, but by the identity of the thread in which it runs. Consequently, if the identity of the thread should change -- some worker thread are enlisted to help, say -- the function misbehaves mysteriously.

 Go encourages a simpler style of programming in which parameters that affect the behavior of a funciton are explicit. Not only does this make programs easier to read, but it lets us freely assign subtasks of a given function to many different goroutines without worrying about their identity.


## 3 Tools

 You've now learned about all the language features you need for writing Go programs.

### 3.1 `go`, `GOPATH` && `GOROOT`

> **go tool**: used for downloading, querying, formatting, building, testing, and installing packages of Go code.

1. `go`: used for downloading, querying, formatting, building, testing, and installing packages of Go code. The `go` combines the features of a diverse set of tools into one command set. It is a package manager (analogous to `apt` or `rpm`) that answers queries about its inventory of packages, computes their dependencies, and downloads them from remote version-control systems. It is a build system that computes file dependencies and invokeds compilers, assemblers, and linkers, although it is intentially less than the standard Unix `make`. And it is a test driver. Its command-line interface uses the `Swiss army knife` style, with over a dozen **subcommands**, some of which we have already seen, like `get`, `run`, `build` and `fmt`. You can run `go help` to see the index of its built-in documentation.

1. `GOPATH`, the root of workspace. This is the only configuration most users need to set. For instance we set `GOPATH` to `$HOME/gobook` while working on this book via `export GOPATH=$HOME/gobook && go get gopl.io/...`. After you download all the programs for this book using the command above, your workspace will contain a hierarchy like this one.  	- `$GOPATH/src` is the package's import path, such as `gopl.io/ch1/helloworld`. Notice it has multiple version-control repositories beneath `src`, such as `gopl.io` or `golang.org`;
	- `$GOPATH/pkg` is where the build tools store compiled packages;
	- `$GOPATH/bin` is where executable programs sits.

2. `GOOROOT`, the root of all the packages of the standard library provided by `Go distribution`. The directory of `GOROOT` resembles that of `GOPATH`. For example, the source files of the `fmt` package reside in the `$GOROOT/src/fmt` directory. Users never need to set `GOROOT` since, by default, the go tool will use the location where it was installed.

The `go env` command prints the effective values of the environment varaibles relevant to the tool chain, including the default values for the missing ones.

### 3.2 Packages

#### 3.2.1 Declare and Access

{% highlight go linenos %}
/*$GOPATH
		- src
			-	helloword
				-	a.go
						package helloword	//this package same should be the same name as the directory
						import "fmt"
						func Say() {
							fmt.Println('Hi, world')
						} 
				-	b.go
			- people
				- c.go
						package people
						import "fmt"
						import "helloworld"	// this is how you import the helloworld package
						func Greet () {
							helloworld.Say()	// use helloworld package's methods.
						}
*/
{% endhighlight %} 


Package level initilization of variable and function.

{% highlight go linenos %}
package example
var a = 3	// initilize the package-level variable

func init() { /* ... */}	// it will be called automatically when the propgram starts, in the order in which they are imported in other package follow the import chain from main. init function in a package cannot be referenced or called manually.
{% endhighlight %}


{% highlight go linenos %}
import (
	"fmt"
	"math/rand"
	crand "math/rand"	// alternative name crand avoids conflict with rand from "math/rand"
	"golang.org/x/net/html"
	"github.com/go-sql-driver/mysql"
	"gopkg.in/yaml.v2"
	_ "image/png"	// initialize the "image/png" package level variables and run its init function
	/*
	1. import path:			"fmt", 	"github.com/go-sql-driver/mysql",		"gopkg.in/yaml.v2"
	2. package name:		"fmt",	"mysql",														"yaml"
	3. version number:	N/A ,  	N/A,																"v2"
	*/


)
{% endhighlight %}

#### 3.2.2 Downloading: `go get`

`go get $GOPATH/src/github.com/golang/ling/golint` download and install the git repository under `$GOPATH/src`, which is actually a git client. If you cd `$GOPATH/src/github.com/golang/lint` and `git remote -v`, you will see `origin  https://github.com/golang/lint (fetch)
origin  https://github.com/golang/lint (push)`. Use `go get -u` do get the latest packages include its dependencies. If you do `go get` without `-u`, the locally existed package will not fetch the latest version.

How to lock a version? More recent go tool support vendoring directly. See `vendor` directories in the output of the `go help gopath` command.

#### 3.2.3 Building: `go build` and `go install`

`go build $GOPATH/src/gopl.io/ch1/helloworld`: if the package is a library, the result is discarded, which merely checks that the packge is free of compile errors; if the package is named `main`, `go build` invokes the linker to create an executable in the current directory and the name of exectuable is taken from the last segment of the package's import path.

By default, `go build` builds the requested package and all its dependencies, the throws away all the compiled code except the final executable, if any. `go install` is similar to `go build` instead saving the compiled code for each package (in `$GOPATH/pkg` direcotry corresponding to the src directory in which the source resides) and command (`$GOPATH/bin` directory). **Many users put `$GOPATH/bin` on their executable search path.**

#### 3.2.4 Documenting: `go doc` and `godoc`

Each delcaration of an exported package var, function and the package declaration itself should be immediately preceded by a comment explaining its purpose and usage. Go doc comments are always complete sentences and the first sentence is usually a summary that starts with the name being declared. Funciton parameters and other identifiers are mentioned wihout quotation or markup. For example the doc comment for `fmt.Fprintf`:

{% highlight go linenos %}
// Fprintf formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encounted.
func Fprintf(w io.Writer, format string, a ...interface{})(int, error)
{% endhighlight %} 

`go doc` prints the declaration and doc comment of the entity, which may be:

1. package: `go doc time`;

2. package member: `go doc time.Since`

3. package method: `go doc time.Duration.Seconds`

another tool `godoc` serves theb cross-linked HTML pages that provide the same information as `go doc` and much more, see [here](https://golang.org/pkg).

#### 3.2.5 Quering: `go list`

`go list` can

1. list any available packages in go workspace: `go list ...`

2. list any available packages in specific subtree: `go list gopl.io/ch3/... 

3. list any available packages for a specific topic: `go list ...xml... 

#### 3.2.6 Internal


{% highlight go linenos %}
/*
net/http/internal/chunked   by importing with "internal" added, chunked is visilbe to net/http/*, but not net/url.

net/http
net/http/httputil
net/url
*/

{% endhighlight %} 

### 3.3 Testing `go test`

test files should follow *_test.go naming. Within test files, there are 3 diffrent test categories

1. **Test**: a test function, whose name prefix `Test`, test the function and return either PASS or FAIL.

2. **Benchmark**: a benchmark function, whose name prefix `Benchmark`, measures the time it takes to call the function (performance test).

3. **Example**: an exmaple function, whose name prefix `Example`, provides machine-checked documentation.


#### 3.3.1 Test (and Coverage)

{% highlight go linenos %}
//add.go
package addLib

func add(args ...int) int {
	sum := 0
	for _, v := range args {
		sum = sum + v
	}
	return sum
}

//add_test.go, test file should follow *_test.go format
package addLib

import "testing"

func TestAdd(t *testing.T) {	// test case start with "Test" followed by tested function name
	var a = 3
	var b = 4
	if add(a, b) != 7 {
		t.Error(`add(3,4) = 7`)
	}
}

//One can use table test
	var tests = []struct {
		input []int
		want  int
	}{
		{[]int{1, 2}, 3},
		{[]int{2, 3}, 5},
		{[]int{3, 4}, 7},
		{[]int{4, 5}, 9},
	}

	for _, test := range tests {
		if got := add(test.input...); got != test.want {
			t.Errorf("add(%d, %d) = %d", test.input[0], test.input[1], test.want)
		}
	}

{% endhighlight %} 

1. `go test` will test the package

2. `go test -cover` will test the package plus show coverage

#### 3.3.2 Benchmark (and Profiling)

{% highlight go linenos %}
// add_test.go
func BenchmarkAdd(b *testing.B) {
	for i := 0; i < b.N; i++ {
		add([]int{1, 2}...)
	}
}

/*
go test -bench=.  // by default, go test will not run Benchmark functions, you need prove -bench flag with matching(. means all)
goos: darwin
goarch: amd64
BenchmarkAdd-8   300000000  4.91 ns/op      // GOMAXPROCS set to 8, run 300000000 times, average add function is 4.91ns
PASS
ok      _/Users/shunmian/Documents/goExample/0_basics/12_testExample    1.966s
{% endhighlight %}
*/

`go test -bench=. `


3 profiling categories:

1. **CPU**: `go test -cpuprofile=cpu.out`, identifies functions whose execution requires most CPU time;

2. **HEAP**: `go test -memrofile=mem.out`, identifies statements wallocat the most memory;

3. **BLOCKING**: `go test -blockrofile=block.out`, identifies operations to block goroutine the longest, such as sytem calls, channel sends and receives, and acquisition sof locks;

use `go tool pprof` to analysis and display the *.out file.


#### 3.3.3 Example

{% highlight go linenos %}
func ExampleAdd() {
	fmt.Println(add([]int{1,2}))
	fmt.Println(3)
	// Output:
	// true
	// true
}
{% endhighlight %}

**Example** servers 3 purposes:

1. for documentation, never decome stale as the code evolves;

2. exectuable tests run by `go test`.

3. hands-on experimentation with `godoc`.


## 4 Basic Algo

### 4.1 Sorting

### 4.2 Searching

#### 4.2.1 Hashing

{% highlight go linenos %}
// Go implements several hash functions in various
// `crypto/*` packages.
import "crypto/sha1"
import "fmt"

func main() {
		s := "sha1 this string"

		// The pattern for generating a hash is `sha1.New()`,
		// `sha1.Write(bytes)`, then `sha1.Sum([]byte{})`.
		// Here we start with a new hash.
		h := sha1.New()

		// `Write` expects bytes. If you have a string `s`,
		// use `[]byte(s)` to coerce it to bytes.
		h.Write([]byte(s))

		// This gets the finalized hash result as a byte
		// slice. The argument to `Sum` can be used to append
		// to an existing byte slice: it usually isn't needed.
		bs := h.Sum(nil)

		// SHA1 values are often printed in hex, for example
		// in git commits. Use the `%x` format verb to convert
		// a hash results to a hex string.
		fmt.Println(s)
		fmt.Printf("%x\n", bs)
}
{% endhighlight %} 

Package names usually take the singular form. The standard packages `bytes`, `errors`, `strings` use the plural to avoid hiding the corresponding predeclared types and  in the case of `go/types` to avoid conflict with a keyword.

Avoid package names that already have other connotations. For example, we originally used the name `temp` for the temperature conversion package. It was a terrible idea because "temp" is an almost universal synonym for "temporary". We went through a brief period with the name `temperature`, but that was too long and didn't say what the package did. In the end, it became `tempconv`, which is shorter and parallel with `strconv`.

For package members name, we should name `fmt.Println` instead of `fmt.PrintlnFormatter` sinc `fmt`(the package name) already include the formatter information. When designing a package, consider how the two parts of a qualified identifier work together, not the member name alone. Here are some characteristic examples: `bytes.Equal`, `flag.Int`, `http.Get`, `json.Marshal`(Marshal, 整理或集结, means gather together people, stuff and organize for a particular purpose).

## 5 Infra

Most frequently used package `bufio`, `bytes`, `flag`, `fmt`, `http`, `io`, `json`, `os`, `sort`, `sync`, `time`, `errors`, `strings`.

### 5.0 IO(`os`,`ioutil`,`bufio`)

#### 5.0.1 Reading

#### 5.0.2 Writing

#### 5.0.3 Line Filter


{% highlight go linenos %}
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	scanner := bufio.NewScanner(os.Stdin)

	for scanner.Scan() {
		ucl := strings.ToUpper(scanner.Text())
		fmt.Println(ucl)
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "error: ", err)
		os.Exit(1)
	}
}
{% endhighlight %} 
使用
{% highlight go linenos %}
$ echo 'hello'   > /tmp/lines
$ echo 'filter' >> /tmp/lines	
$ cat /tmp/lines | go run line-filters.go
HELLO
FILTER
{% endhighlight %} 

### 5.1 Panic

exit program with status 2


### 5.2 `reflect`

1. `reflect.TypeOf(aVar)` vs `reflect.TypeOf(aVar).Kind()`;

### 5.3 `regexp`

{% highlight go linenos %}
import "bytes"
import "fmt"
import "regexp"

func main() {

		// This tests whether a pattern matches a string.
		match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
		fmt.Println(match)
}
{% endhighlight %} 

### 5.4 `encoding/json`

{% highlight go linenos %}
import (
	"encoding/json"
	"fmt"
)
type response1 struct {
	Page   int
	Fruits []string
}

func main() {
	res1D := &response1{
		Page:   1,
		Fruits: []string{"apple", "peach", "pear"}}
	res1B, _ := json.Marshal(res1D)
	fmt.Println(string(res1B))

	str := `{"Page": 1, "Fruits": ["apple", "peach"]}`
	res := response1{}
	json.Unmarshal([]byte(str), &res)
	fmt.Println(res)
}
{% endhighlight %} 

### 5.5 `time`

#### 5.5.0 Basic time

{% highlight go linenos %}
import (
	"fmt"
	"reflect"
	"time"
)

func main() {
	p := fmt.Println

	now := time.Now()
	p(now)
	then := time.Date(
		2009, 11, 17, 20, 34, 58, 36812763812638, time.UTC)
	p(then)
	p(then.Year())
	p(then.Month())
	p(then.Day())
	p(then.Hour())
	p(then.Minute())
	p(then.Second())
	p(then.Nanosecond())
	p(then.Location())

	p(then.Weekday())
	p(then.Before(now))
	p(then.After(now))
	p(then.Equal(now))

	diff := now.Sub(then)
	p("diff", reflect.TypeOf(diff))
	p(diff)

	p(diff.Hours())
	p(diff.Minutes())


	secs := time.Now().Unix()
	p("time to epoch: ", secs)               // 1541217165
	p("epoch to time: ", time.Unix(secs, 0)) // 2018-11-03 11:52:45 +0800 HKT
}
{% endhighlight %} 


#### 5.5.1 Timer

> Timer: Timers are for when you want to do something once in the future

{% highlight go linenos %}

	timer1 := time.NewTimer(2 * time.Second)

	<-timer1.C
	fmt.Println("Timer 1 expired")

	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 expired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

{% endhighlight %}

#### 5.5.2 Ticker

> Tickers are for when you want to do something repeatedly at regular intervals.

{% highlight go linenos %}
func main() { // main goroutine
	ticker := time.NewTicker(500 * time.Millisecond)
	go func() {
		for t := range ticker.C {
			fmt.Println("Tick at", t)
		}
	}()

	time.Sleep(1600 * time.Millisecond)
	ticker.Stop()
	fmt.Println("Ticker stopped")
}
{% endhighlight %} 

### 5.6 `math/rand`

{% highlight go linenos %}
import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	p := fmt.Println
	// each time run, it produce the same sequence
	p(rand.Intn(100), ",")
	p(rand.Intn(100))
	p(rand.Float64())
	// in order to produce different sequence, you need provide a seed. Time is a good seed
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	p(r1.Intn(100))
}
{% endhighlight %} 


### 5.7 `strconv`

{% highlight go linenos %}
import (
	"fmt"
	"strconv"
)

func main() {
	p := fmt.Println

	f, _ := strconv.ParseFloat("1.234", 64)
	p(f)

	i, _ := strconv.ParseInt("123", 0, 64)
	p(i)

	k, _ := strconv.Atoi("135")
	p(k)

	l, _ := strconv.Atoi("wat")
	p(l)
}
{% endhighlight %}


### 5.8 `net/url`

{% highlight go linenos %}
import "fmt"
import "net"
import "net/url"

func main() {
		s := "postgres://user:pass@host.com:5432/path?k=v#f"

		u, err := url.Parse(s)
		if err != nil {
				panic(err)
		}

		fmt.Println(u.Scheme)
		fmt.Println(u.User)
		fmt.Println(u.User.Username())
		p, _ := u.User.Password()
		fmt.Println(p)
		fmt.Println(u.Host)
		host, port, _ := net.SplitHostPort(u.Host)
		fmt.Println(host)
		fmt.Println(port)
		fmt.Println(u.Path)
		fmt.Println(u.Fragment)
		fmt.Println(u.RawQuery)
		m, _ := url.ParseQuery(u.RawQuery)
		fmt.Println(m)
		fmt.Println(m["k"][0])
}
{% endhighlight %} 

### 5.8 `os`

#### 5.8.1 command line args
{% highlight go linenos %}
func main() {
	argsWithProg := os.Args
	argsWithoutProg := os.Args[1:]

	arg := os.Args[3]

	fmt.Println(argsWithProg)
	fmt.Println(argsWithoutProg)
	fmt.Println(arg)
}
{% endhighlight %} 


{% highlight go linenos %}
{% endhighlight %} 

#### 5.8.1.1 command line `flag`

{% highlight go linenos %}
import (
	"flag"
	"fmt"
)

func main() {
	wordPtr := flag.String("word", "foo", "a string")
	numbPtr := flag.Int("num", 42, "an int")

	flag.Parse()

	fmt.Println("word: ", *wordPtr)
	fmt.Println("numb: ", *numbPtr)
}
{% endhighlight %} 

#### 5.8.2 Env

{% highlight go linenos %}
import (
	"fmt"
	"os"
	"strings"
)

func main() {
	os.Setenv("FOO", "1")
	fmt.Println("FOO: ", os.Getenv("FOO"))
	for _, e := range os.Environ() {
		pair := strings.Split(e, "=")
		fmt.Println(pair[0])
	}
}
{% endhighlight %} 

#### 5.8.3 Process

##### 5.8.3.1 Spawn a process

Spawn an external process, and make it accessible through the parent go process

{% highlight go linenos %}
import (
	"fmt"
	"os/exec"
)

func main() {
	dateCmd := exec.Command("date")
	dateOut, err := dateCmd.Output()
	if err != nil {
		panic(err)
	}
	fmt.Println("> date")
	fmt.Println(string(dateOut))
}
{% endhighlight %}

##### 5.8.3.2 Exec a process

Exec an external process to relace the current go process

{% highlight go linenos %}
import "syscall"
import "os"
import "os/exec"

func main() {
	binary, lookErr := exec.LookPath("ls")
	if lookErr != nil {
		panic(lookErr)
	}
	args := []string{"ls", "-a", "-l", "-h"}
	env := os.Environ()
	execErr := syscall.Exec(binary, args, env)
	if execErr != nil {
		panic(execErr)
	}
}

{% endhighlight %}

#### 5.8.4 Signal `os/signal`, `syscall`

{% highlight go linenos %}
// Sometimes we'd like our Go programs to intelligently
// handle [Unix signals](http://en.wikipedia.org/wiki/Unix_signal).
// For example, we might want a server to gracefully
// shutdown when it receives a `SIGTERM`, or a command-line
// tool to stop processing input if it receives a `SIGINT`.
// Here's how to handle signals in Go with channels.

package main

import "fmt"
import "os"
import "os/signal"
import "syscall"

func main() {

	// Go signal notification works by sending `os.Signal`
	// values on a channel. We'll create a channel to
	// receive these notifications (we'll also make one to
	// notify us when the program can exit).
	sigs := make(chan os.Signal, 1)
	done := make(chan bool, 1)

	// `signal.Notify` registers the given channel to
	// receive notifications of the specified signals.
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	// This goroutine executes a blocking receive for
	// signals. When it gets one it'll print it out
	// and then notify the program that it can finish.
	go func() {
		sig := <-sigs
		fmt.Println()
		fmt.Println(sig)
		done <- true
	}()

	// The program will wait here until it gets the
	// expected signal (as indicated by the goroutine
	// above sending a value on `done`) and then exit.
	fmt.Println("awaiting signal")
	<-done
	fmt.Println("exiting")
}

{% endhighlight %} 


#### 5.8.5 Exit

Note that unlike e.g. C, Go does not use an integer return value from main to indicate exit status. If you’d like to exit with a non-zero status you should use os.Exit.

{% highlight go linenos %}

import "fmt"
import "os"

func main() {
	defer fmt.Println("!")
	os.Exit(3)
}

{% endhighlight %}

## A1

{% highlight go linenos %}
{% endhighlight %} 


### A1.1 new function

> **new**, a built-in function to create an unamed variable of type T and return &T. `new` is rarely used in go.

The following two functions are identical

{% highlight go linenos %}
func newInt1() *int{
	return new(int)
}

func newInt2() *int{
	var dummyInt int
	return &dummyInt
} 
{% endhighlight %} 

### A1.2 make function

> **make**, a built-in function to take a type T, which must be a slice, map or channel type,


### A1.3 iota

> **iota**: in a const declaration, the value of iota begins at zero and increments by one for each item in the sequence.

The following declares Sunday to be 0, Monday to be 1, and so on.
{% highlight go linenos %}
type Weekday int

const {
	Sunday Weekday = iota
	Monday
	Tudesday
	Wednesday
	Thursday
	Friday
	Saturday
}
{% endhighlight %}

### A1.4 `range`

### A1.5 `error`

### A1.6 `a ...interface{}`


{% highlight go linenos %}
//add.go
package addLib

func add(args ...int) int {
	sum := 0
	for _, v := range args {
		sum = sum + v
	}
	return sum
}

//add_test.go, test file should follow *_test.go format
package addLib

import "testing"

//One can use table test
	var tests = []struct {
		input []int
		want  int
	}{
		{[]int{1, 2}, 3},
		{[]int{2, 3}, 5},
		{[]int{3, 4}, 7},
		{[]int{4, 5}, 9},
	}

	for _, test := range tests {
		if got := add(test.input...); got != test.want {
			t.Errorf("add(%d, %d) = %d", test.input[0], test.input[1], test.want)
		}
	}

{% endhighlight %} 

## A2 Go problems

### A2.1 Go doesn't support generic

## 4 总结 ##

{: .img_middle_hg}
![Network overview](/assets/images/posts/2014-06-01-C Review/Chapter 14 The Preprocessor.png)


## 5 Reference ##

- [《The Go Programming Language》](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440);

- [《Go Documenation》](https://golang.org/doc/)

- [《Go Package](https://golang.org/pkg/)

- [《Effective Go](https://golang.org/doc/effective_go.html)



