---
layout: post
title: C++ Review
categories: [00 CPP]
tags: [CPP]
number: [0.1]
fullview: false
shortinfo: 本文是对《C++ Primer》的一个读书总结。

---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## Part 0

> `item1.isbn()`, the return of dot operator is the member named by the right-hand operand, which is isbn.

> `expression`: the smallest unit of computation; `function`: a named unit of computations. `statement`, an expression followed by a semiconlon, executing a expression; `function invocation`, function followed by ().

## Part I The Bacisc ##

### C2 Variables and Basic Types

#### C2.2 variable

{% highlight cpp linenos %}
std::string empty;  // empty implicitly initialized to the empty string
Sales_item item;    // default-initialized Sales_item object
{% endhighlight %}

> Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.

#### C2.3 references & pointer

pointer，用来传递大的数据。拷贝一份太慢，就拷贝地址。尽量所有参数都传引用，int, double也可以。为了防止引用的内容被改，可以参数传递时指定`const Complex&`。 返回值也尽量reference来返回。

> reference跟pointer一样，但是使用形式不一样。函数定义`void swap(int &v1, int &v2){ temp = v1; v1 = v2; v2 = temp}`使用`&`引用，函数调用`swap(v1, v2)`只需正常调用，就可以交换v1和v2的值了。而用指针需要 `void swap(int *v1, int *v2) { temp = (*v1); (*v1) = (*v2); (*v2) = temp; }`，调用时用swap(&v1, &v2)。显然指针版本会对使用者造成额外负担，而引用版本只需函数实现者在参数输入上加上&，其他无额外负担, 而对于函数调用者来说，无任何负担。

> reference变量在define时必须初始化。reference变量不能重新赋值。`int i = 1; int &refVal = i; int &refVal2 //error: a reference must be initialized`

> reference变量不能被初始化字面值(literal) `int &refVal = 10; // error: initializer must be an object`, `int i = 10; int &refVal = i;`

{% highlight cpp linenos %}
// & and * have different meaning. 
int i = 42;
int &r = i;     // & follows a type and is part of a declaration; r is a reference;
int *p;         // * follows a type and is part of a declaration; p is a pointer;
p = &i;         // & is used in an expression as the address of operator;
*p = i;         // * is used in an expression as the dereference operator;
int &r2 = *p;   // & is part of the declaration; * is the dereference operator;
{% endhighlight %}

> It is possible for pointer1, pointing to obj1,  and pointer 2, pointing to one pass the end of obj2 have the same address. In this case `(pointer1 == pointer2)` is true.

> Use `int *p1, *p2` to define multiple pointers in one statement. Note `*` is adjascent to `p1` and `p2`, not `int* p1, p2` (adjascent to int), which is confusing.

#### C2.4 const

> A `const` type can use most but not all of the same operations as its `nonconst` version.

#### C2.6 Defining Our Own Data Structure

{% highlight cpp linenos %}
#include <iostream>
using namespace std;

struct Sales_data {
    // in-class initializer, bookNo = ""; unitSold = 0; revenue = 3.0;
    string bookNo;     
    int unitsSold = 0;
    double revenue = 3.0;
};

int main() {
    Sales_data item1;   // Class variable without an initializer are default initialized with in-class initializer
    cout << item1.bookNo << endl
         << item1.unitsSold << endl
         << item1.revenue << endl;
}
{% endhighlight %}


{% highlight cpp linenos %}
// Header Guides
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <iostream>
#include <string>
using namespace std;
struct Sales_data {
    string bookNo;     
    int unitsSold = 0;
    double revenue = 3.0;
};

#endif
{% endhighlight %}


### C3 Strings, Vectors and Arrays

`Array` are built-in type

`String` and `Vector` are implemented on top of `Array`

#### C3.1 Strings

#### C3.2 Vectors

`Vector` is a template.
`Vector <int>` is a type.

`it->mem` is a synonym for `(*it).mem`

#### C3.3 Arrays

### C4 Expressions

### C5 Statements

### C6 Functions

### C7 Classes

#### C7.1 copy constructor



move constructor

operator overloading (+,-,*,/)

## Part II The C++ Library

### C8 The IO Library

### C9 Sequential Containers

### C10 Generic Algorithms

### C11 Associative Containers

### C12 Dynamic Memory

## Part III Tools for Class Authors

### C13 Copy Control

### C14 Overloaded Operations and Conversions

### C15 Objective-Oriented Programming

### C16 Templates and Generic Programming

## Part IV Advanced Topics

### C17 Specialized Library Facilities

### C18 Tools for Large Programs

### C19 Specialized Techniques and Tools


## 4 Appendix

### 4.1 Smart pointer

RAII principle

unique_ptr: `std::unique_ptr<int> p1 {new int {100}}`
shared_ptr: like `strong` in ObjC
weak_ptr: like `weak` in ObjC

custom deleter

### 4.2 Exception handler

## 5 Assembly with C++

`for (auto &c : aString)` vs for `(auto c : aString)`


## 6 总结 ##

{% highlight cpp linenos %}
{% endhighlight %}

{: .img_middle_hg}
![Network overview](/assets/images/posts/2014-06-01-C Review/Chapter 14 The Preprocessor.png)


## 5 Reference ##

- [《C++Primer》](https://book.douban.com/subject/24089577/);
- [《STL源码剖析》](https://book.douban.com/subject/1110934/);
- [《深度探索c++对象模型》](https://book.douban.com/subject/10427315/);



