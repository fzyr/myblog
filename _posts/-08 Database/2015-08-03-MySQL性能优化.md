---
layout: post
title: MySQL性能优化
categories: [-08 Database]
tags: [Database,MySQL]
number: [-6.1.1]
fullview: false
shortinfo: 《MySQL性能优化》笔记。

---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## 1 A Broad Overview ##

### CH1 MySQL Architecture and History

## 2 Building a Solid Foundation

### CH2 Benchmarking MySQL

### CH3 Profiling Server Performance

### CH4 Optimizaing Schema and Data Types




### CH5&6 QUERY OPTIMIZATION

#### CH5 Indexing for High Performance

##### 1. 草稿

- principle: 
    - leftmost prefix principle 最左前缀原则
- type:
    - b-tree (most common): `auto increment primary key` store the whole row by b-tree. `key(col1, col2, col3)` the column order is of great importance as leftmost prefix principle since the key is stored in b-tree with soreted order first by col1; when col1 equals, then by col2; when col1, col2 equals then by col3. so the following queries will be boosted by the index `key(col1, col2, col3)`:
        - `where col1 = AA`, `where col1 > AA`;
        - `where col1 = A`, `where col1 > AA`; // col1的prefix
        - `where col1 = A and col2 = B`; `where col1 = A and col2 > B`;
        - `where col1 = A and col2 = B and col3 = C`; `where col1 = A and col2 = B and col3 > C`; 
    if you want to query `where col1 > A and col2 = B`, you need to make another key with different order, `key(col2, col1)`.
    - hash: ligntning fast for exact match, no use for range query.
    - spatial R-tree index.

- When and when not use index: an index isn't always the right tool, indexes are effective when they help the storage engine find rows without adding more work than they avoid.
    - For small tables, it is often more effective to simply read all the rows in the table.
    - For medium to large tables, indexes can be very effective
    - For enormous tables, the overhead of indexing, as well as the work required to actually use the indexes, can start to add up. In such cases you might need to choose a technique that identifies groups of rows that are interesting to the query, instead of individual rows. You can use partitioning for this purpose.

- Index Strategies for High Performance
    - Isolating the column (indexed column must be along on one side of comparison operator): 假设bank table有13列，有id为主键，则`SELECT * FROM bank WHERE id = 10`和`SELECT * FROM bank WHERE id + 1 = 11`的结果一样，但是搜索涉及的row截然不同，使用`explain`命令可得前者row为1，后者row为13.

#### CH6 Query Performance Optimization








### CH7 Advanced MySQL Features

## 3 Configuring Your Application

### CH8 Optimizaing Server Settings

### CH9 Operating System and Hardware Optimization

## 4 MySQL as an Infrasturcture Component

### CH10 Replication

### CH11 Scaling MySQL

### CH12 High Availability

### CH13 MySQL in the Cloud

### CH14 Application-Level Optimization

### CH15 Backup and Recovery

## 5 Miscellanoues Useful Topics

### CH16 Tools for MySQL Users

### Appendix A

### Appendix B

### Appendix C

## 3 总结 ##



{: .img_middle_hg}
![regular expression](/assets/images/posts/2015-06-01/client mysql.jpg)


## 4 参考资料 ##
- [《High Performance MySQL》](https://book.douban.com/subject/10443458/);





