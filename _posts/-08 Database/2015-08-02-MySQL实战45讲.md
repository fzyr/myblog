---
layout: post
title: MySQL实战45讲
categories: [-08 Database]
tags: [Database,MySQL]
number: [-6.1.1]
fullview: false
shortinfo: 极客时间林晓斌《MySQL实战45讲》笔记。

---
目录
{:.article_content_title}


* TOC
{:toc}

---
{:.hr-short-left}

## 1 基础篇 ##

主要知识点

- 事务，
- 索引，
- 锁，

### 1 基础架构: 一条SQL查询语句是如何执行的

{: .img_middle_lg}
![mysql structure]({{site.url}}/assets/images/posts/-08 Database/MySQL实战45讲/mysql structure.png)

### 2 日志系统: 一条SQL更新语句是如何执行的

`update T set c=c+1 where ID = 2;`

> Mysql可以恢复到半个月内任意一秒的转态。

> WAL(write-ahead logging): 先写日志，再写磁盘。

两个log：

- Redolog, 在innoDB实现。物理日志，记录的是在某个数据页上做了什么修改，只有“我”这个存储引擎能用，别人没有共享我的“物理格式”。Redolog的大小固定，一般4G，write pos 追 checkpoint，环形内存。`update T set c=c+1 where ID = 2;`，先写redolog到硬盘，事后再写row的更新到硬盘，由于redolog是顺序写，row更新需要"找位置"，因此先持久redolog更快，这就是为什么用WAL.

- Binlog, 在mysql server层实现。Binlog，是逻辑日志，记录的是`update T set c=c+1 where ID = 2;`， 可以给别的数据库，别的存储引擎使用，大家都通晓这个"逻辑"。记录了所有历史，

{: .img_middle_mid}
![mysql structure]({{site.url}}/assets/images/posts/-08 Database/MySQL实战45讲/the process for update sql.png)

### 3 事务隔离: 为什么你改了我还看不见

- dirty read: read uncommitted

- unrepeatable read: the row's value is different among several reads within A transaction since B transaction is changing it during A transaction.

- phantom read: the row appear to exist then disappear after later read within A transaction since B transaction is updating or deleting the row during A transaction.


{: .img_middle_mid}
![mysql structure]({{site.url}}/assets/images/posts/-08 Database/MySQL实战45讲/ACID.png)


### 4 深入浅出索引(上)

- B+ tree
- Hash index for equality and B+ tree for range
- [clustered index and secondary index]({{site.url}}/-08%20database/2015/08/03/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html#ch5-indexing-for-high-performance)

### 5 深入浅出索引(下)

#### 5.1 索引覆盖

{% highlight mysql linenos %}
CREATE table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');

 /*
 1. k索引树找到k=3的entry，获取primary key ID = 300
 2. primary key索引树获取ID=300对应的R3(回表)
 3. k索引树找到k=5的entry，获取primary key ID = 500
 4. primary key索引树获取ID=500对应的R4(回表)
 5. 在k索引树取下一个值k=6, 不满足条件，循环结束
 */
select * from T where k between 3 and 5;

 /*
 1. k索引树找到k=3的entry，获取primary key ID = 300
 2. k索引树找到k=5的entry，获取primary key ID = 500
 3. 在k索引树取下一个值k=6, 不满足条件，循环结束
 */
select ID from T where k between 3 and 5;
{% endhighlight %}

> Covering Index(覆盖索引)指的是辅助索引上已有query的信息，不需要回表。覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

#### 5.2 最左前缀原则

{% highlight mysql linenos %}
CREATE table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index ks(k, s))
engine=InnoDB;

/*
index ks(k,s)是按k排序，再在相同k里按s排序，因此index ks(k,s)是index k(k)的一个超集，你不需要再加index k(k)。 同时index ks(k,s)还可以用覆盖索引通过k获取s值。
*/

{% endhighlight %}

> 最左前缀原则：联合索引是按字段出现顺序排序的，因此可以按最左的N个字段索引，也可以是字符串索引的最左M个字符。利用最左前缀原则，可以减少索引表，复用索引。如何利用好最左前缀原则关键在于建立联合索引的时候**字段的顺序**， 如果通过调准顺序，可以减少维护一个索引，那么这个顺序应该优先考虑。

#### 5.3 索引下推

{% highlight mysql linenos %}
CREATE table T (
ID int primary key,
k int NOT NULL DEFAULT 0,
s varchar(16) NOT NULL DEFAULT '',
index ks(k, s))
engine=InnoDB;

/*
由于最左前缀原则，index ks(k,s)可以用来定位k=3, 然后呢？Mysql 5.6之前，只能从ID=300开始回表，到主键索引数上找出数据行，再对比字段s="aa"; Mysql 5.6之后，引入了索引下推优化(index condition pushdown), 可以在索引便利过程中，对索引中包含的字段优先做判断，直接过滤掉不满足的记录，减少回表次数。
*/
select * from T where k between 3 and 5 and s = "aa"

{% endhighlight %}

{: .img_middle_hg}
![regular expression]({{site.url}}/assets/images/posts/-08 Database/MySQL实战45讲/索引下推优化.png)

#### 5.4 课后题

{% highlight mysql linenos %}
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
{% endhighlight %}

公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。

但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？同事告诉他，是因为他们的业务里面有这样的两种语句：

{% highlight mysql linenos %}
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
{% endhighlight %}

> Q:这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？

> A: 当主键是`(a, b)`时，定义为`(c)`的索引，实际上是`(c, a, b)`。所以4个索引分别是 `(a, b)`, `(c, a, b)`, `(c, a, b)`, `(c, b, a)`。所以 KEY `ca` (`c`,`a`) 可以省略。

### 6 全局锁和表锁: 给表加个字段怎么有这么多阻碍

- 全局锁
- 表锁
- 行锁

### 7 行锁功过: 怎么减少行锁对性能的影响

行锁：
  - 两阶段锁协议
    - 事务启动时，某行锁的获取在其sql语句执行前，锁的释放不在其sql语句释放后，而是事务提交。因此如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发的锁的申请时机尽量往后

  - 死锁： 调整sql语句顺序并不能避免死锁，减少死锁主要通过控制访问相同资源德31并发事务量。死锁检测`innodb_deadlock_detect`=`on`，当死锁发生时，会回滚其中一个事务来试图打破死锁，但是死锁检测很耗费CPU资源，复杂度是`O(N^2)`。3种方案解决热点行更新导致的性能问题。
    - 关闭`innodb_deadlock_detect`，前提是你知道没有死锁，不然当死锁发生时，会有大量相关事务超时。
    - 控制并发量
      - 客户端，可以但是提高有限
      - 数据库服务端：
        - 中间件， 对于相同行的更新，在进入引擎之前排队。
        - 将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。
    
     

### 8 事务到底是隔离的还是不隔离的

InnoDB的行数据有多个版本，每个数据版本有自己的`row trx_id`, 每个事务或者语句有自己的一致性试图。普通查询语句是一致性读，一致性读会根据row trx_id和一致性试图确定数据版本的可见性。

事务隔离的各个级别是通过每个事务的事务数组和每行数据的`row_trx_id`来实现的。

{: .img_middle_hg}
![regular expression]({{site.url}}/assets/images/posts/-08 Database/MySQL实战45讲/transaction isolation level implementation.png)

## 2 实践篇

### 9 普通索引和唯一索引，应该怎么选择


redo log vs change buffer:

- redo log 主要节省的是随机磁盘的IO消耗(转成顺序写)

- change buffer主要节省的则是随机读磁盘的IO消耗(当要update时，需要读入磁盘原来数据，然后在原来数据上更新；若有change buffer, 则省略这一步)

{: .img_middle_hg}
![regular expression]({{site.url}}/assets/images/posts/-08 Database/MySQL实战45讲/change buffer.png)



### 10 Mysql为什么有时候回选错索引

索引统计有其内在更新机制，由于索引统计信息不准确导致的问题，可以用`analyze table t`来更新索引统计信息解决。而对于其他优化器误判的情况，你可以在应用端用`force index`来强行指定索引，页可以通过修改语句来引导优化器，还可以通过增加或删除索引来绕过这个问题。

### 11 怎么给字符串字段加索引

### 12 为什么我的Mysql会“抖”一下

### 13 为什么表数据删掉一半，表文件大小不变

### 14 `count(*)`这么慢，我该怎么办

### 15 答疑文章(一)：日志和索引相关问题

### 16 `order by`是怎么工作的

### 17 如何正确地显示随机消息

### 18 为什么这些sql语句逻辑相同，性能却差异巨大

### 19 为什么我只查一行的语句，也执行这么慢

### 20 幻读是什么，幻读有什么问题

### 21 为什么我只查一行的语句， 锁这么多

### 22 MySql有哪些“饮鸩止渴”提高性能的方法

### 23 MySql是怎么保证数据不丢的

### 24 MySql是怎么保证主备一致的

### 25 MySql是怎么保证高可用的

### 26 备库为什么会延迟好几个小时

### 27 主库出问题了， 从库怎么办

### 28 读写分离有哪些坑

### 29 如何判断一个数据库是不是出问题了

### 30 答疑文章(二): 用动态的观点看加锁

### 31 误删数据后除了跑路，还能怎么办

### 32 为什么还有Kill不掉的语句

### 33 我查这么多数据，会不会把数据库内存打爆

### 34 到底可不可以使用`join`

### 35 `join`语句怎么优化

### 36 为什么临时表可以重名

### 37 什么时候会使用内部临时表

### 38 都说`InnoDB`好，那还要不要使用Memory引擎

### 39 自增主键为什么不是连续的

### 40 `insert`语句的锁为什么这么多

### 41 怎么最快地复制一张表

### 42 `grant`之后要跟着`flush privileges`吗

### 43 要不要使用分区表

### 44 答疑文章(三)

### 45 递增id用完了怎么办



## 3 总结 ##



{: .img_middle_hg}
![regular expression]({{site.url}}/assets/images/posts/2015-06-01/client mysql.jpg)


## 4 参考资料 ##
- [《MySQL in One Tutorial》](https://www.youtube.com/watch?v=yPu6qV5byu4);
- [《MySQL Cookbook》](https://www.amazon.com/MySQL-Cookbook-Paul-DuBois/dp/059652708X/ref=sr_1_2?ie=UTF8&qid=1469005314&sr=8-2&keywords=mysql+cookbook);
- [《MySQL Tutorial》](http://www.tutorialspoint.com/mysql/);





